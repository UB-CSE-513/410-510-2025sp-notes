\documentclass{lecturenotes}

\usepackage[colorlinks,urlcolor=blue]{hyperref}
\usepackage{doi}
\usepackage{xspace}
\usepackage{fontspec}
\usepackage{enumerate}
\usepackage{mathpartir}
\usepackage{pl-syntax/pl-syntax}
\usepackage{forest}
\usepackage{stmaryrd}
\usepackage{epigraph}
\usepackage{xspace}
\usepackage{bbm}
\usepackage{tikz-cd}
\usepackage{unicode-math}

\setsansfont{Fira Code}
\setmathfont{AsanaMath}

\newcommand{\abs}[2]{\ensuremath{\lambda #1.\,#2}}
\newcommand{\tabs}[3]{\ensuremath{\lambda #1 \colon #2.\,#3}}
\newcommand{\dbabs}[1]{\ensuremath{\lambda.\,#1}}
\newcommand{\dbind}[1]{\ensuremath{\text{\textasciigrave}#1}}
\newcommand{\app}[2]{\ensuremath{#1\;#2}}
\newcommand{\utype}{\textsf{unit}\xspace}
\newcommand{\unit}{\ensuremath{\textsf{(}\mkern0.5mu\textsf{)}}}
\newcommand{\prodtype}[2]{\ensuremath{#1 \times #2}}
\newcommand{\pair}[2]{\ensuremath{(#1, #2)}}
\newcommand{\projl}[1]{\ensuremath{\pi_1\mkern2mu#1}}
\newcommand{\projr}[1]{\ensuremath{\pi_2\mkern3mu#1}}
\newcommand{\sumtype}[2]{\ensuremath{#1 + #2}}
\newcommand{\injl}[1]{\ensuremath{\textsf{inj}_1\mkern2mu#1}}
\newcommand{\injr}[1]{\ensuremath{\textsf{inj}_2\mkern3mu#1}}
\newcommand{\case}[5]{\ensuremath{\textsf{case}\mkern5mu#1\mkern5mu\textsf{of}\mkern5mu\injl{#2} \Rightarrow #3;\mkern5mu\injr{#4} \Rightarrow #5\mkern5mu\textsf{end}}}
\newcommand{\vtype}{\textsf{void}\xspace}
\newcommand{\vcase}[1]{\ensuremath{\textsf{case}\mkern5mu#1\mkern5mu\textsf{of}\mkern5mu\textsf{end}}}
\newcommand{\rectype}[2]{\ensuremath{\mu #1.\,#2}}
\newcommand{\roll}[1]{\textsf{roll}\mkern2mu#1}
\newcommand{\unroll}[1]{\textsf{unroll}\mkern2mu#1}
\newcommand{\fatype}[2]{\ensuremath{\forall #1.\,#2}}
\newcommand{\Abs}[2]{\Lambda #1.\,#2}
\newcommand{\App}[2]{#1\;[#2]}
\newcommand{\extype}[2]{\ensuremath{\exists #1.\,#2}}
\newcommand{\pack}[3]{\ensuremath{\textsf{pack}\mkern5mu#1\mathrel{\textsf{as}}#2\mathrel{\textsf{in}}#3}}
\newcommand{\unpack}[4]{\ensuremath{\textsf{unpack}\mkern5mu#1\mathrel{\textsf{as}} #2, #3 \mathrel{\textsf{in}} #4}}
\newcommand{\ltype}[1]{\ensuremath{\textsf{list}\mkern3mu#1}}
\newcommand{\nillist}{\ensuremath{[\,]}}
\newcommand{\conslist}[2]{\ensuremath{#1 \mathop{::} #2}}
\newcommand{\lcase}[5]{\ensuremath{\textsf{case}\mkern5mu#1\mkern5mu\textsf{of}\mkern5mu\nillist\Rightarrow#2; \mkern5mu\conslist{#3}{#4} \Rightarrow #5\mkern5mu\textsf{end}}}
\newcommand{\logn}[1]{\ensuremath{\textsf{log}\mkern3mu#1}}
\renewcommand{\tt}{\textsf{true}\xspace}
\newcommand{\ff}{\textsf{false}\xspace}
\newcommand{\ite}[3]{\ensuremath{\textsf{if}~#1 \mathrel{\textsf{then}} #2 \mathrel{\textsf{else}} #3}}
\newcommand{\send}[2]{\ensuremath{\textsf{send}~#1 \mathrel{\textsf{to}} #2}}
\newcommand{\recv}[3]{\ensuremath{\textsf{receive}~#1 \mathrel{\textsf{from}} #2} \mathrel{\textsf{in}} #3}
\newcommand{\Left}{\textsf{left}\xspace}
\newcommand{\Right}{\textsf{right}\xspace}
\newcommand{\choosefor}[2]{\ensuremath{\textsf{choose}~#1 \mathrel{\textsf{for}} #2}}
\newcommand{\letchoose}[3]{\ensuremath{\textsf{let}~#1 \mathrel{\textsf{choose}} (\Left \Rightarrow #2; \Right \Rightarrow #3)}}
\newcommand{\letchooseL}[2]{\ensuremath{\textsf{let}~#1 \mathrel{\textsf{choose}} (\Left \Rightarrow #2)}}
\newcommand{\letchooseR}[2]{\ensuremath{\textsf{let}~#1 \mathrel{\textsf{choose}} (\Right \Rightarrow #2)}}
\newcommand{\ret}[1]{\ensuremath{\textsf{ret}(#1)}}


\newcommand{\capture}[1]{\ensuremath{\lfloor #1 \rfloor}}
\newcommand{\bind}[1]{\ensuremath{\textsf{bind}(#1)}}

\newcommand{\pureeff}{\textsf{pure}\xspace}
\newcommand{\logeff}{\textsf{log}\xspace}

\newcommand{\FV}{\text{FV}}
\newcommand{\BV}{\text{BV}}

\newcommand{\toform}[1]{\ensuremath{\lceil #1 \rceil}}
\newcommand{\totype}[1]{\ensuremath{\lfloor #1 \rfloor}}

\newcommand{\neutral}[1]{#1\;\text{ne}}
\newcommand{\nf}[1]{#1\;\text{nf}}

\newcommand{\subtype}{\ensuremath{\mathrel{\mathord{<}\mathord{:}}}}

\newcommand{\pub}{\text{public}}
\newcommand{\priv}{\text{secret}}

\newcommand{\at}{\ensuremath{\mathrel{@}}}

\newcommand{\obj}[1]{\ensuremath{\mathcal{O}(#1)}}
\renewcommand{\hom}[3][]{\ensuremath{\text{Hom}_{#1}(#2, #3)}}
\newcommand{\id}[1][]{\ensuremath{\mathbbm{1}_{#1}}}

\newcommand{\Set}{\textbf{Set}\xspace}
\newcommand{\Rel}{\textbf{Rel}\xspace}
\newcommand{\Type}{\textbf{Type}\xspace}
\newcommand{\Cat}{\textbf{Cat}\xspace}

\newcommand{\op}[1]{\ensuremath{{#1}^{\text{op}}}}

\newcommand{\prodmor}[2]{\ensuremath{\langle #1, #2 \rangle}}
\newcommand{\inl}{\text{inl}\xspace}
\newcommand{\inr}{\text{inr}\xspace}
\newcommand{\coprodmor}[2]{\ensuremath{[ #1, #2 ]}}

\newcommand{\sendrecv}[4]{\ensuremath{#1.#2 \rightsquigarrow #3.#4}}
\newcommand{\syncmsg}[3]{\ensuremath{#1.[#2] \rightsquigarrow #3}}
\newcommand{\chorif}[4]{\ensuremath{\textsf{if}~#1.#2 \mathrel{\textsf{then}} #3 \mathrel{\textsf{else}} #4}}

\newcommand{\sendrecva}[3]{\ensuremath{#1.#2 \rightsquigarrow #3}}
\newcommand{\syncmsga}[3]{\ensuremath{#1.[#2] \rightsquigarrow #3}}
\newcommand{\senda}[2]{\ensuremath{#1 \rightsquigarrow #2}}
\newcommand{\recva}[2]{\ensuremath{#1 \leftsquigarrow #2}}
\newcommand{\sendsynca}[2]{\ensuremath{[#1] \rightsquigarrow #2}}
\newcommand{\recvsynca}[2]{\ensuremath{[#1] \leftsquigarrow #2}}

\newcommand{\projection}[2]{\ensuremath{\llbracket #1 \rrbracket_{#2}}}

\title{Choreographies, Part I}
\coursenumber{CSE 410/510}
\coursename{Programming Language Theory}
\lecturenumber{37}
\semester{Spring 2025}
\professor{Professor Andrew K. Hirsch}

\begin{document}
\maketitle

\begin{itemize}
\item Up until now in this module, we have focused on concurrent $\lambda$~calculi.
  These have the ability to describe communication, but they are vulnerable to deadlocks.
\item When dealing with similar problems in sequential $\lambda$~calculi, we have handled the problem using a type system.
  However, type systems don't solve the problem here.

  \noindent\textbf{Stop and Think:} Why not?
  Try to think at a fundamental level about what goes wrong with concurrency that doesn't with any of the other systems we've seen.
\item Nothing stops us from writing a mismatch of sends and receives that leads to two processes each waiting on the other.
  In order for a type system to stop this, it must do more than keep track of the shape of data; it must keep track of the behavior of each process.
\item We can then move to \emph{behavioral type systems}, such as session types.
  However, these are quite complicated, and often require ``writing the program twice:'' once in the program and once in the type.
\item As an alternative, we can take another perspective on concurrent programming, especially in the CCS style.
  Here's the idea: we are trying to write one program involving multiple processes.
  Instead of writing a bunch of programs (one for each process) and trying to hand organize them so that they work together, \textbf{why not just write the program you wanted}?
\item In order to do this, we need a way of writing a single program that describes the interactions of many processes.
  We can do this using \emph{choreographic programming.}
\item In choreographic programming, we write one program representing a whole system.
  Thus, we write $\sendrecv{p}{v}{q}{x}$ to mean ``the process~$p$ sends value~$v$ to the process~$q$, who stores it as~$x$.''
\item Today, we're going to talk about a simple choreographic programming language.
\end{itemize}

\begin{syntax}
  \category[Actions]{\alpha} \alternative{\varepsilon} \alternative{\sendrecva{p}{m}{q}} \alternative{\syncmsga{p}{d}{q}}
  \category[Messages]{m} \alternative{x} \alternative{\tilde{n}} \alternative{\tt} \alternative{\ff}
  \category[Choreographies]{\mathcal{C}} \alternative{p.m} \alternative{\sendrecv{p}{m}{q}{x}; \mathcal{C}} \alternative{\syncmsg{p}{d}{q}; \mathcal{C}} \alternative{\chorif{p}{m}{\mathcal{C}_1}{\mathcal{C}_2}}
\end{syntax}

\begin{itemize}
\item Note that variables $x$ store messages.
\item There is a (trivial) definition of substitution on messages $$m_1 [x \mapsto m_2] = \left\{\begin{array}{ll} m_2 & \text{if}~m_1 = x\\m_1 & \text{otherwise}\end{array}\right.$$
\item On choreographies, we get a definition of substitution for each process.
  Intuitively, each process has its own namespace which must be respected: $p.x \neq q.x$.
\item We can define this as follows:
{  \def\oldarraystretch{\arraystretch}
  \def\arraystretch{1.5}
  $$
  \mathcal{C}[p \mid x \mapsto m] = \left\{
    \begin{array}{ll}
      p.(m' [x \mapsto m]) & \mathcal{C} = p.m'\\
      q.m' & \mathcal{C} = q.m' \land p \neq q\\
      \sendrecv{q}{m'}{p}{x}; \mathcal{C}' & \mathcal{C} = \sendrecv{p}{m'}{q}{y}; \mathcal{C}' \land p \neq q\\
      \sendrecv{p}{(m'[x \mapsto m])}{p}{x}; \mathcal{C}' & \mathcal{C} = \sendrecv{p}{m'}{p}{x}; \mathcal{C}'\\
      \sendrecv{p}{(m'[x \mapsto m])}{q}{y}; (\mathcal{C}' [p \mid x \mapsto m]) & \mathcal{C} = \sendrecv{p}{m'}{q}{y}; \mathcal{C}' \land (p \neq q \lor x \neq y)\\
      \sendrecv{q}{(m'[x \mapsto m])}{r}{y}; (\mathcal{C}' [p \mid x \mapsto m]) & \mathcal{C} = \sendrecv{q}{m'}{r}{y}; \mathcal{C}' \land p \neq q \land (p \neq r \lor x \neq y)\\
      \syncmsg{q}{d}{r}; (\mathcal{C}'[p \mid x \mapsto m]) & \mathcal{C} = \syncmsg{q}{d}{r}; \mathcal{C}'\\[1em]
      {\def\arraystretch{1}
      \hspace{-0.7em}\begin{array}[t]{l}\textsf{if}~p.(m' [x \mapsto m])\\
        \textsf{then}~\mathcal{C}_1[p \mid x \mapsto m]\\
        \textsf{else}~\mathcal{C}_2[p \mid x \mapsto m]
      \end{array}}
      & \mathcal{C} = \chorif{p}{m'}{\mathcal{C}_1}{\mathcal{C}_2}\\
      {\def\arraystretch{1}
      \hspace{-0.7em}\begin{array}[t]{l}
        \textsf{if}~q.m'\\
        \textsf{then}~\mathcal{C}_1[p \mid x \mapsto m]\\
        \textsf{else}~\mathcal{C}_2[p \mid x \mapsto m]
      \end{array}
      }
      & \mathcal{C} = \chorif{q}{m'}{\mathcal{C}_1}{\mathcal{C}_2} \land q \neq p\\
    \end{array}
  \right.
  $$
}
\item As before, we define the semantics of our language with an LTS (i.e., a labeled transition system).
\item However, we also allow \emph{out-of-order execution}.
  That is, we allow parts of the program to execute whenever it would be allowed when each process is running concurrently.
\item In order to do this, we define a function describing the process names of an action:
  $$
  \text{pn}(\alpha) = \left\{\begin{array}{ll} \varnothing & \alpha = \varepsilon\\ \{p, q\} & \alpha = \sendrecva{p}{m}{q}\\ \{p, q\} & \alpha = \syncmsga{p}{d}{q}\end{array}\right.
  $$
\item In order to perform an action out of order, none of the processes ``above'' the action can be taking an action.
  Thus, for each process there is a single canonical action that the process takes.
\end{itemize}

\begin{mathpar}
  \sendrecv{p}{m}{q}{x}; \mathcal{C} \xrightarrow{\sendrecva{p}{m}{q}} \mathcal{C}[q \mid x \mapsto m] \and
  \infer{\mathcal{C} \xrightarrow{\alpha} \mathcal{C}' \\ p, q \not\in\text{pn}(\alpha)}{\sendrecv{p}{m}{q}{x}; \mathcal{C} \xrightarrow{\alpha} \sendrecv{p}{m}{q}{x}; \mathcal{C}'} \\
  \syncmsg{p}{d}{q}; \mathcal{C} \xrightarrow{\syncmsga{p}{d}{q}} \mathcal{C} \and
  \infer{\mathcal{C} \xrightarrow{\alpha} \mathcal{C}'\\ p, q \not\in\text{pn}(\alpha)}{\syncmsg{p}{d}{q}; \mathcal{C} \xrightarrow{\alpha} \syncmsg{p}{d}{q}; \mathcal{C}'}\\
  \chorif{p}{\tt}{\mathcal{C}_1}{\mathcal{C}_2} \xrightarrow{\varepsilon} \mathcal{C}_1 \and
  \chorif{p}{\ff}{\mathcal{C}_1}{\mathcal{C}_2} \xrightarrow{\varepsilon} \mathcal{C}_2 \and
\end{mathpar}

\begin{itemize}
\item However, it may not be obvious why this is a concurrent program.
\item In order to remedy that, we define a quick process calculus:
  \begin{syntax}
    \category[Expressions]{e} \alternative{\unit} \alternative{\ret{m}} \alternative{\send{m}{p}; e} \alternative{\recv{x}{p}{e}} \alternative{\choosefor{d}{p}; e}\\
    \alternative{\letchoose{p}{e_1}{e_2}}\\ \alternative{\letchooseL{p}{e}} \alternative{\letchooseR{p}{e}}\\
    \alternative{\ite{e_1}{e_2}{e_3}}
    \category[Actions]{a} \alternative{\varepsilon} \alternative{\senda{m}{p}} \alternative{\recva{m}{p}} \alternative{\sendsynca{d}{p}} \alternative{\recvsynca{d}{p}}
  \end{syntax}
  \begin{mathpar}
    \send{m}{p}; e \xrightarrow{\senda{m}{p}} e \and
    \recv{x}{p}{e} \xrightarrow{\recva{m}{p}} e[x \mapsto m] \and
    \choosefor{d}{p}; e \xrightarrow{\sendsynca{d}{p}} e \\
    \letchoose{p}{e_1}{e_2} \xrightarrow{\recvsynca{\Left}{p}} e_1 \and
    \letchoose{p}{e_1}{e_2} \xrightarrow{\recvsynca{\Right}{p}} e_2 \\
    \letchooseL{p}{e} \xrightarrow{\recvsynca{\Left}{p}} e_1 \and
    \letchooseR{p}{e} \xrightarrow{\recvsynca{\Right}{p}} e_1\\
    \ite{\ret{\tt}}{e_1}{e_2} \xrightarrow{\varepsilon} e_1 \and
    \ite{\ret{\ff}}{e_1}{e_2} \xrightarrow{\varepsilon} e_2
  \end{mathpar}
\item This looks a lot like what we've seen before, but now it's possible to only offer one of the choices of \Left and \Right.
\item We can then translate our choreographies into process-calculus terms.
  For every process~$p$, we define a process-calculus term $\projection{\mathcal{C}}{p}$ describing $p$'s actions in $\mathcal{C}$.
  Defining this makes it clear why we need these single-offer terms:
\end{itemize}

$$
\projection{\mathcal{C}}{p} = \left\{\begin{array}{ll}
  \ret{m} & \mathcal{C} = p.m\\
  \unit & \mathcal{C} = q.m \land p \neq q\\
  \send{m}{q}; \projection{\mathcal{C}'}{p} & \mathcal{C} = \sendrecv{p}{m}{q}{x}; \mathcal{C}' \land p \neq q\\
  \recv{x}{q}{\projection{\mathcal{C}'}{p}} & \mathcal{C} = \sendrecv{q}{m}{p}{x}; \mathcal{C}' \land p \neq q\\
  \projection{\mathcal{C}'}{p} & \mathcal{C} = \sendrecv{q}{m}{r}{x}; \mathcal{C}' \land p \neq q \land p \neq r\\
  \choosefor{d}{q}; \projection{\mathcal{C}'}{p} & \mathcal{C} = \syncmsg{p}{d}{q}; \mathcal{C}' \land p \neq q\\
  \letchooseL{q}{\projection{\mathcal{C}'}{p}} & \mathcal{C} = \syncmsg{q}{\Left}{p}; \mathcal{C}' \land p \neq q\\
  \letchooseR{q}{\projection{\mathcal{C}'}{p}} & \mathcal{C} = \syncmsg{q}{\Right}{p}; \mathcal{C}' \land p \neq q\\
  \projection{\mathcal{C}'}{p} & \mathcal{C} = \sendrecv{q}{d}{r}; \mathcal{C}' \land p \neq q \land p \neq r\\
  \ite{\ret{m}}{\projection{\mathcal{C}_1}{p}}{\projection{\mathcal{C}_2}{p}} & \mathcal{C} = \chorif{p}{m}{\mathcal{C}_1}{\mathcal{C}_2}\\
  \projection{\mathcal{C}_1}{p} \sqcup \projection{\mathcal{C}_2}{p} & \mathcal{C} = \chorif{q}{m}{\mathcal{C}_1}{\mathcal{C}_2} \land p \neq q\\
  \text{undefined} & \text{otherwise}
  \end{array}\right.
$$

\begin{itemize}
\item For most of the syntax of choreographies, projection is easy to define.
  \begin{itemize}
  \item For instance, returning a message~$m$ at process~$p$ turns into $m$ for $p$, and $\unit$ for everyone else.
  \item Process~$p$ sending a message~$m$ to process~$q$ turns into $p$ sending $m$ to $q$, $q$ receiving form $p$, and everyone else skipping the instruction.
  \item Choice messages turn into the sender sending either $\Left$ or $\Right$, while the receiver offers either $\Left$ or $\Right$, but not both.
  \item The tricky case is \textsf{if}: for the owner of the discriminee, things are easy.
    But for everyone else, we get two programs: their actions in one branch and their actions in the other.
    We need some way to \emph{merge} these programs together, which we write $\projection{\mathcal{C}_1}{p} \sqcup \projection{\mathcal{C}_2}{p}$.
    The details of that merge we leave for next time.
  \end{itemize}
\end{itemize}


\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% TeX-engine: luatex
%%% End:
