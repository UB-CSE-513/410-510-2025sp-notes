\documentclass{lecturenotes}

\usepackage[colorlinks,urlcolor=blue]{hyperref}
\usepackage{doi}
\usepackage{xspace}
\usepackage{agda}
\usepackage{fontspec}
\usepackage{enumerate}
\usepackage{mathpartir}
\usepackage{pl-syntax/pl-syntax}
\usepackage{forest}
\usepackage{stmaryrd}

\setsansfont{Fira Code}
\usepackage{newunicodechar}
\newunicodechar{∣}{\ensuremath{\mid}}
\newunicodechar{′}{\ensuremath{{}^\prime}}
\newunicodechar{ˡ}{\ensuremath{{}^{\textsf{l}}}}
\newunicodechar{ʳ}{\ensuremath{{}^{\textsf{r}}}}
\newunicodechar{≤}{\ensuremath{\mathord{\leq}}}
\newunicodechar{≡}{\ensuremath{\mathord{\equiv}}}
\newunicodechar{≐}{\ensuremath{\mathord{\doteq}}}
\newunicodechar{∘}{\ensuremath{\circ}}
\newunicodechar{≃}{\ensuremath{\simeq}}
\newunicodechar{≲}{\ensuremath{\precsim}}
\newunicodechar{⊎}{\ensuremath{\uplus}}
\newunicodechar{≟}{\ensuremath{\stackrel{?}{=}}}
\newunicodechar{̬}{\ensuremath{{}_{\textsf{v}}}}
\newunicodechar{ₐ}{\ensuremath{{}_{\textsf{a}}}}
\newunicodechar{ₜ}{\ensuremath{{}_{\textsf{t}}}}
\newunicodechar{ₖ}{\ensuremath{{}_{\textsf{k}}}}
\newunicodechar{₁}{\ensuremath{{}_{1}}}
\newunicodechar{₂}{\ensuremath{{}_{2}}}
\newunicodechar{₃}{\ensuremath{{}_{3}}}
\newunicodechar{⊕}{\ensuremath{\oplus}}
\newunicodechar{⊗}{\ensuremath{\otimes}}
\newunicodechar{σ}{\ensuremath{\sigma}}
\newunicodechar{∸}{\ensuremath{\stackrel{.}{-}}}
\newunicodechar{≮}{\ensuremath{\not<}}
\newunicodechar{⋆}{\ensuremath{{}^{\ast}}}
\newunicodechar{⇓}{\ensuremath{\Downarrow}}

\newcommand{\Imp}{\textsc{Imp}\xspace}
\newcommand{\Skip}{\textsf{skip}}
\newcommand{\ite}[3]{\ensuremath{\textsf{if}\mkern5mu#1 \mathrel{\textsf{then}} #2 \mathrel{\textsf{else}} #3}}
\newcommand{\while}[2]{\ensuremath{\textsf{while}\mkern5mu#1 \mathrel{\textsf{do}} #2}}
\newcommand{\itrue}{\textsf{true}}
\newcommand{\ifalse}{\textsf{false}}

\newcommand{\astep}{\ensuremath{\mathrel{\longrightarrow_a}}}
\newcommand{\bstep}{\ensuremath{\mathrel{\longrightarrow_b}}}
\newcommand{\cstep}{\ensuremath{\mathrel{\longrightarrow_c}}}

\title{Denotational Semantics}
\coursenumber{CSE 410/510}
\coursename{Programming Language Theory}
\lecturenumber{11}
\semester{Spring 2025}
\professor{Professor Andrew K. Hirsch}

\begin{document}
\maketitle

\begin{code}[hide]
module lec11-akh where

import Relation.Binary.PropositionalEquality as Eq
open Eq using (_≡_; _≢_; refl; cong; sym)
open Eq.≡-Reasoning
open import Data.Nat using (ℕ; zero; suc; _+_; _*_; _∸_; _<_; z<s; s<s; _≤_; _>_)
open import Data.Product using (_×_; proj₁; proj₂) renaming (_,_ to ⟨_,_⟩)
open import Data.Bool using (Bool; true; false; if_then_else_)
open import Relation.Nullary using (Dec; yes; no; ¬_)

module Imp where

import Relation.Binary.PropositionalEquality as Eq
open Eq using (_≡_; _≢_; refl; cong; sym)
open Eq.≡-Reasoning
open import Data.Nat using (ℕ; zero; suc; _+_; _*_; _∸_; _<_; z<s; s<s; _≤_; _>_)
open import Data.Product using (_×_; proj₁; proj₂) renaming (_,_ to ⟨_,_⟩)
open import Data.Bool using (Bool; true; false; if_then_else_)
open import Relation.Nullary using (Dec; yes; no; ¬_)

postulate
  Var : Set
  _≟̬_ : ∀ (X Y : Var) → Dec (X ≡ Y)

_≟_ : ∀ (n m : ℕ) → Dec (n ≡ m)
zero ≟ zero = yes refl
zero ≟ (suc m) = no λ ()
(suc n) ≟ zero = no λ ()
(suc n) ≟ (suc m) with n ≟ m
... | yes eq  = yes (cong suc eq)
... | no neq = no (λ {refl -> neq refl}) 

nat-eqb : ∀ (n m : ℕ) → Bool
nat-eqb zero zero = true
nat-eqb zero (suc _) = false
nat-eqb (suc _) zero = false
nat-eqb (suc n) (suc m) = nat-eqb n m

nat-eqb-true : ∀ {n m : ℕ} → nat-eqb n m ≡ true → n ≡ m
nat-eqb-true {zero} {zero} eqbnm≡true = refl
nat-eqb-true {suc n} {suc m} eqbnm≡true  = cong suc (nat-eqb-true {n} {m} eqbnm≡true)

neq-suc′ : ∀ {n m : ℕ} → suc n ≢ suc m → n ≢ m
neq-suc′ {n} {m} neq = λ eq → neq (cong suc eq)

suc-eq : ∀ {n m : ℕ} → suc n ≡ suc m → n ≡ m
suc-eq refl = refl

neq-suc : ∀ {n m : ℕ} → n ≢ m → suc n ≢ suc m
neq-suc {n} {m} neq = λ {eq → neq (suc-eq eq)} 

nat-eqb-false : ∀ {n m : ℕ} → nat-eqb n m ≡ false → n ≢ m
nat-eqb-false {zero} {suc m} eqbnm≡false = λ ()
nat-eqb-false {suc n} {zero} eqbnm≡false = λ () 
nat-eqb-false {suc n} {suc m} eqbnm≡false = neq-suc (nat-eqb-false {n} {m} eqbnm≡false)

nat-eqb-equal : ∀ {n m : ℕ} → n ≡ m → nat-eqb n m ≡ true
nat-eqb-equal {zero} {zero} eq = refl
nat-eqb-equal {suc n} {suc m} eq = nat-eqb-equal (suc-eq eq)

nat-eqb-refl : ∀ {n : ℕ} → nat-eqb n n ≡ true
nat-eqb-refl {zero} = refl
nat-eqb-refl {suc n} = nat-eqb-refl {n}

nat-eqb-nequal : ∀ {n m : ℕ} → n ≢ m → nat-eqb n m ≡ false
nat-eqb-nequal {zero} {zero} neq with (neq refl)
... | () 
nat-eqb-nequal {zero} {suc m} neq = refl
nat-eqb-nequal {suc n} {zero} neq = refl
nat-eqb-nequal {suc n} {suc m} neq = nat-eqb-nequal (neq-suc′ neq)

_≟ₜ_ : ∀ (b₁ b₂ : Bool) → Dec (b₁ ≡ b₂)
false ≟ₜ false = yes refl
false ≟ₜ true = no λ ()
true ≟ₜ false = no λ ()
true ≟ₜ true = yes refl

_<?_ : (n m : ℕ) → Dec (n < m)
zero <? zero = no λ ()
zero <? suc m = yes z<s
suc n <? zero = no λ ()
suc n <? suc m with n <? m
... | yes n<m = yes (s<s n<m)
... | no n≮m = no (λ {(s<s pf) → n≮m pf}) 

ltb : ℕ → ℕ → Bool
ltb zero zero = false
ltb zero (suc _) = true
ltb (suc m) zero = false
ltb (suc m) (suc n) = ltb m n

ltb-true : ∀ {m n : ℕ} → ltb m n ≡ true → m < n
ltb-true {zero} {suc n} m<?n≡true = z<s
ltb-true {suc m} {suc n} m<?n≡true = s<s (ltb-true m<?n≡true)

<-ltb : ∀ {m n : ℕ} → m < n → ltb m n ≡ true
<-ltb {zero} {suc n} m<n = refl
<-ltb {suc m} {suc n} (Data.Nat.s≤s m<n) = <-ltb {m} {n} m<n

≮-ltb : ∀ {n m : ℕ} → ¬ (n < m) → ltb n m ≡ false
≮-ltb {zero} {zero} n≮m = refl
≮-ltb {zero} {suc m} n≮m with n≮m z<s
... | ()
≮-ltb {suc n} {zero} n≮m = refl
≮-ltb {suc n} {suc m} n≮m = ≮-ltb {n} {m} λ n<m → n≮m (s<s n<m)

data AExpr : Set where
  const : ℕ → AExpr
  var : Var → AExpr
  _⊕_ : AExpr → AExpr → AExpr
  _-_ : AExpr → AExpr → AExpr
  _⊗_ : AExpr → AExpr → AExpr

infixr 5 _⊕_
infixr 5 _-_
infixr 4 _⊗_

data BExpr : Set where
  true : BExpr
  false : BExpr
  _==_ : AExpr → AExpr → BExpr
  _<<_ : AExpr → AExpr → BExpr
  !_ : BExpr → BExpr
  _&&_ : BExpr → BExpr → BExpr
  _||_ : BExpr → BExpr → BExpr

infixr 3 _&&_
infixr 3 _||_

bool2BExpr : Bool → BExpr
bool2BExpr true = true
bool2BExpr false = false

data Com : Set where
  skip : Com
  _:=_ : Var → AExpr → Com
  _>>_ : Com → Com → Com
  ite : BExpr → Com → Com → Com
  while_go_ : BExpr → Com → Com


infixr 2 _⟶ₐ_

State = Var → ℕ

update : State → Var → ℕ → State
update σ X n Y with X ≟̬ Y
... | yes _ = n
... | no _ = σ Y 

AConfig = AExpr × State

-- note: this is a long arrow \-->
data _⟶ₐ_ : AConfig → AExpr → Set where
  var-lookup : ∀ {X : Var} {σ : State} →
    ⟨ var X , σ ⟩ ⟶ₐ const (σ X)
  plus-step₁ : ∀ {x y z : AExpr}{σ : State} →
         ⟨ x , σ ⟩ ⟶ₐ z →
    ------------------------
     ⟨ x ⊕ y , σ ⟩ ⟶ₐ z ⊕ y
  plus-step₂ : ∀ {x y z : AExpr} {σ : State}→
         ⟨ y , σ ⟩ ⟶ₐ z →
    ------------------------
     ⟨ x ⊕ y , σ ⟩ ⟶ₐ x ⊕ z
  plus-step-const : ∀ {n m : ℕ} {σ : State} →
    ------------------------------------------------
     ⟨ (const n) ⊕ (const m) , σ ⟩ ⟶ₐ const (n + m)
  minus-step₁ : ∀ {x y z : AExpr}{σ : State} →
         ⟨ x , σ ⟩ ⟶ₐ z →
    ------------------------
     ⟨ x - y , σ ⟩ ⟶ₐ z - y
  minus-step₂ : ∀ {x y z : AExpr} {σ : State} →
         ⟨ y , σ ⟩ ⟶ₐ z →
    ------------------------
     ⟨ x - y , σ ⟩ ⟶ₐ x - z
  minus-step-const : ∀ {n m : ℕ} {σ : State} →
    ------------------------------------------------
     ⟨ (const n) - (const m) , σ ⟩ ⟶ₐ const (n ∸ m) 
  times-step₁ : ∀ {x y z : AExpr} {σ : State} →
         ⟨ x , σ ⟩ ⟶ₐ z →
    ------------------------
     ⟨ x ⊗ y , σ ⟩ ⟶ₐ z ⊗ y
  times-step₂ : ∀ {x y z : AExpr} {σ : State} →
         ⟨ y , σ ⟩ ⟶ₐ z →
    ------------------------
     ⟨ x ⊗ y , σ ⟩ ⟶ₐ x ⊗ z
  times-step-const : ∀ {n m : ℕ} {σ : State} →
    ------------------------------------------------
     ⟨ (const n) ⊗ (const m) , σ ⟩ ⟶ₐ const (n * m)

BConfig = BExpr × State

infixr 2 _⟶ₜ_
data _⟶ₜ_ : BConfig → BExpr → Set where
  eq-step₁ : ∀ {x y z : AExpr} {σ : State} →
          ⟨ x , σ ⟩ ⟶ₐ z → 
    --------------------------
     ⟨ x == y , σ ⟩ ⟶ₜ z == y
  eq-step₂ : ∀ {x y z : AExpr} {σ : State} →
          ⟨ y , σ ⟩ ⟶ₐ z →
    --------------------------
     ⟨ x == y , σ ⟩ ⟶ₜ x == z
  eq-step-true : ∀ {n : ℕ} {σ : State} →
    ------------------------------------------------------
     ⟨ (const n) == (const n) , σ ⟩ ⟶ₜ true
  eq-step-false : ∀ {n m : ℕ} {σ : State} →
                    n ≢ m ->
    ----------------------------------------
    ⟨ (const n) == (const m) , σ ⟩ ⟶ₜ false
  lt-step₁ : ∀ {x y z : AExpr} {σ : State} →
          ⟨ x , σ ⟩ ⟶ₐ z →
    --------------------------
     ⟨ x << y , σ ⟩ ⟶ₜ z << y 
  lt-step₂ : ∀ {x y z : AExpr} {σ : State} →
          ⟨ y , σ ⟩ ⟶ₐ z →
    --------------------------
     ⟨ x << y , σ ⟩ ⟶ₜ x << z
  lt-step-true : ∀ {n m : ℕ} {σ : State} →
                                  n < m →
    ---------------------------------------------------------
     ⟨ (const n) << (const m) , σ ⟩ ⟶ₜ true
  lt-step-false : ∀ {n m : ℕ} {σ : State} →
                                 ¬ (n < m) → 
    ---------------------------------------------------------
     ⟨ (const n) << (const m) , σ ⟩ ⟶ₜ false

  not-step : ∀ {b₁ b₂ : BExpr} {σ : State} →
       ⟨ b₁ , σ ⟩ ⟶ₜ b₂ →
    ----------------------
     ⟨ ! b₁ , σ ⟩ ⟶ₜ ! b₂
  not-true : ∀ {σ : State} →
    -------------------------
     ⟨ ! true , σ ⟩ ⟶ₜ false
  not-false : ∀ {σ : State} → 
    -----------------
     ⟨ ! false , σ ⟩ ⟶ₜ true
  and-step₁ : ∀ {b₁ b₂ b₃ : BExpr} {σ : State} →
           ⟨ b₁ , σ ⟩ ⟶ₜ b₃ →
    ------------------------------
     ⟨ b₁ && b₂ , σ ⟩ ⟶ₜ b₃ && b₂
  and-true : ∀ {b₂ : BExpr} {σ : State} →
    --------------------------
     ⟨ true && b₂ , σ ⟩ ⟶ₜ b₂
  and-false : ∀ {b₂ : BExpr} {σ : State} →
    ------------------------------
     ⟨ false && b₂ , σ ⟩ ⟶ₜ false
  or-step₁ : ∀ {b₁ b₂ b₃ : BExpr} {σ : State} →
           ⟨ b₁ , σ ⟩ ⟶ₜ b₃ →
    ------------------------------
     ⟨ b₁ || b₂ , σ ⟩ ⟶ₜ b₃ || b₂
  or-true : ∀ {b₂ : BExpr} {σ : State}→
    ----------------------------
     ⟨ true || b₂ , σ ⟩ ⟶ₜ true
  or-false : ∀ {b₂ : BExpr} {σ : State} →
    ---------------------------
     ⟨ false || b₂ , σ ⟩ ⟶ₜ b₂

Config = Com × State

infixr 2 _⟶ₖ_
data _⟶ₖ_ : Config → Config → Set where
  step-assgn : ∀ {X : Var} {e₁ e₂ : AExpr} {σ : State} →
          ⟨ e₁ , σ ⟩ ⟶ₐ e₂ →
    ------------------------------------
     ⟨ X := e₁ , σ ⟩ ⟶ₖ ⟨ X := e₂ , σ ⟩
  assgn-const : ∀ {X : Var} {n : ℕ} {σ : State} →
    -------------------------------------------------
     ⟨ X := const n , σ ⟩ ⟶ₖ ⟨ skip , update σ X n ⟩
  step->> : ∀ {c₁ c₂ c₁′ : Com} {σ σ′ : State} →
            ⟨ c₁ , σ ⟩ ⟶ₖ ⟨ c₁′ , σ′ ⟩ →
    ------------------------------------------
     ⟨ c₁ >> c₂ , σ ⟩ ⟶ₖ ⟨ c₁′ >> c₂ , σ′ ⟩
  skip->> : ∀ {c : Com} {σ : State} →
    ---------------------------------
     ⟨ skip >> c , σ ⟩ ⟶ₖ ⟨ c , σ ⟩
  step-ite : ∀ {b b′ : BExpr} {c₁ c₂ : Com} {σ : State} →
               ⟨ b , σ ⟩ ⟶ₜ b′ →
    ---------------------------------------------
     ⟨ ite b c₁ c₂ , σ ⟩ ⟶ₖ ⟨ ite b′ c₁ c₂ , σ ⟩ 
  ite-true : ∀ {c₁ c₂ : Com} {σ : State} →
    --------------------------------------
     ⟨ ite true c₁ c₂ , σ ⟩ ⟶ₖ ⟨ c₁ , σ ⟩
  ite-false : ∀ {c₁ c₂ : Com} {σ : State} →
    --------------------------------------
     ⟨ ite false c₁ c₂ , σ ⟩ ⟶ₖ ⟨ c₂ , σ ⟩
  step-while : ∀ {b : BExpr} {c : Com} {σ : State} →
    -------------------------------------------------------------------
     ⟨ while b go c , σ ⟩ ⟶ₖ ⟨ ite b (c >> (while b go c)) skip , σ ⟩ 

infixr 2 _⟶ₐ⋆_

data _⟶ₐ⋆_ : AConfig → AExpr → Set where 
  step-zero : ∀ {e : AExpr} {σ : State} →
    -----------------
     ⟨ e , σ ⟩ ⟶ₐ⋆ e
  step-many : ∀ {e₁ e₂ e₃ : AExpr} {σ : State} →
    ⟨ e₁ , σ ⟩ ⟶ₐ  e₂ →
    ⟨ e₂ , σ ⟩ ⟶ₐ⋆ e₃ →
    ---------------------
      ⟨ e₁ , σ ⟩ ⟶ₐ⋆ e₃ 

⟶ₐ⋆-trans : ∀ {e₁ e₂ e₃ : AExpr} {σ : State} →
  ⟨ e₁ , σ ⟩ ⟶ₐ⋆ e₂ →
  ⟨ e₂ , σ ⟩ ⟶ₐ⋆ e₃ →
  --------------------
  ⟨ e₁ , σ ⟩ ⟶ₐ⋆ e₃
⟶ₐ⋆-trans step-zero stps2 = stps2
⟶ₐ⋆-trans (step-many stp stps1) stps2 = step-many stp (⟶ₐ⋆-trans stps1 stps2)

plus-steps₁ : ∀ {e₁ e₁′ e₂ : AExpr} {σ : State} →
        ⟨ e₁ , σ ⟩ ⟶ₐ⋆ e₁′ →
  ------------------------------
   ⟨ e₁ ⊕ e₂ , σ ⟩ ⟶ₐ⋆ e₁′ ⊕ e₂
plus-steps₁ step-zero = step-zero
plus-steps₁ (step-many stp stps) = step-many (plus-step₁ stp) (plus-steps₁ stps)

plus-steps₂ : ∀ {e₁ e₂ e₂′ : AExpr} {σ : State} →
         ⟨ e₂ , σ ⟩ ⟶ₐ⋆ e₂′ →
  -------------------------------
    ⟨ e₁ ⊕ e₂ , σ ⟩ ⟶ₐ⋆ e₁ ⊕ e₂′
plus-steps₂ step-zero = step-zero
plus-steps₂ (step-many stp stps) = step-many (plus-step₂ stp) (plus-steps₂ stps)

minus-steps₁ : ∀ {e₁ e₁′ e₂ : AExpr} {σ : State} →
        ⟨ e₁ , σ ⟩ ⟶ₐ⋆ e₁′ →
  ------------------------------
   ⟨ e₁ - e₂ , σ ⟩ ⟶ₐ⋆ e₁′ - e₂
minus-steps₁ step-zero = step-zero
minus-steps₁ (step-many stp stps) = step-many (minus-step₁ stp) (minus-steps₁ stps)

minus-steps₂ : ∀ {e₁ e₂ e₂′ : AExpr} {σ : State} →
         ⟨ e₂ , σ ⟩ ⟶ₐ⋆ e₂′ →
  -------------------------------
    ⟨ e₁ - e₂ , σ ⟩ ⟶ₐ⋆ e₁ - e₂′
minus-steps₂ step-zero = step-zero
minus-steps₂ (step-many stp stps) = step-many (minus-step₂ stp) (minus-steps₂ stps)

times-steps₁ : ∀ {e₁ e₁′ e₂ : AExpr} {σ : State} →
        ⟨ e₁ , σ ⟩ ⟶ₐ⋆ e₁′ →
  ------------------------------
   ⟨ e₁ ⊗ e₂ , σ ⟩ ⟶ₐ⋆ e₁′ ⊗ e₂
times-steps₁ step-zero = step-zero
times-steps₁ (step-many stp stps) = step-many (times-step₁ stp) (times-steps₁ stps)

times-steps₂ : ∀ {e₁ e₂ e₂′ : AExpr} {σ : State} →
         ⟨ e₂ , σ ⟩ ⟶ₐ⋆ e₂′ →
  -------------------------------
    ⟨ e₁ ⊗ e₂ , σ ⟩ ⟶ₐ⋆ e₁ ⊗ e₂′
times-steps₂ step-zero = step-zero
times-steps₂ (step-many stp stps) = step-many (times-step₂ stp) (times-steps₂ stps)


infixr 2 _⇓ₐ_

data _⇓ₐ_ : AConfig → ℕ → Set where
  const-eval : ∀ {n : ℕ} {σ : State} →
               ----------------------
                ⟨ const n , σ ⟩ ⇓ₐ n
  var-eval : ∀ {x : Var} {σ : State} →
             --------------------------
               ⟨ var x , σ ⟩ ⇓ₐ (σ x)
  plus-eval : ∀ {e1 e2 : AExpr} {σ : State} {n m : ℕ} →
         ⟨ e1 , σ ⟩ ⇓ₐ n →
         ⟨ e2 , σ ⟩ ⇓ₐ m →
    --------------------------
     ⟨ e1 ⊕ e2 , σ ⟩ ⇓ₐ n + m
  minus-eval : ∀ {e1 e2 : AExpr} {σ : State} {n m : ℕ} →
         ⟨ e1 , σ ⟩ ⇓ₐ n →
         ⟨ e2 , σ ⟩ ⇓ₐ m →
    --------------------------
     ⟨ e1 - e2 , σ ⟩ ⇓ₐ n ∸ m
  times-eval : ∀ {e1 e2 : AExpr} {σ : State} {n m : ℕ} →
         ⟨ e1 , σ ⟩ ⇓ₐ n →
         ⟨ e2 , σ ⟩ ⇓ₐ m →
    --------------------------
     ⟨ e1 ⊗ e2 , σ ⟩ ⇓ₐ n * m


⇓ₐ-⟶ₐ⋆ : ∀ {c : AConfig} {n : ℕ} → c ⇓ₐ n → c ⟶ₐ⋆ const n
⇓ₐ-⟶ₐ⋆ {⟨ const n , σ ⟩} {n} const-eval = step-zero
⇓ₐ-⟶ₐ⋆ {⟨ var x , σ ⟩} {n} var-eval = step-many var-lookup step-zero
⇓ₐ-⟶ₐ⋆ {⟨ e1 ⊕ e2 , σ ⟩} {_} (plus-eval {e1} {e2} {σ} {n} {m} ev₁ ev₂) =
  ⟶ₐ⋆-trans (plus-steps₁ (⇓ₐ-⟶ₐ⋆ ev₁))
 (⟶ₐ⋆-trans (plus-steps₂ (⇓ₐ-⟶ₐ⋆ ev₂))
            (step-many plus-step-const step-zero))
⇓ₐ-⟶ₐ⋆ {⟨ e₁ - e₂ , σ ⟩} {_} (minus-eval {e₁} {e₂} {σ} {n} {m} ev₁ ev₂) =
  ⟶ₐ⋆-trans (minus-steps₁ (⇓ₐ-⟶ₐ⋆ ev₁))
 (⟶ₐ⋆-trans (minus-steps₂ (⇓ₐ-⟶ₐ⋆ ev₂))
            (step-many minus-step-const step-zero))
⇓ₐ-⟶ₐ⋆ {c} {n} (times-eval ev₁ ev₂) = 
  ⟶ₐ⋆-trans (times-steps₁ (⇓ₐ-⟶ₐ⋆ ev₁))
 (⟶ₐ⋆-trans (times-steps₂ (⇓ₐ-⟶ₐ⋆ ev₂))
            (step-many times-step-const step-zero))

⟶ₐ-⇓ₐ : ∀ {e₁ e₂ : AExpr} {σ : State} {n : ℕ} →
   ⟨ e₁ , σ ⟩ ⟶ₐ e₂ →
   ⟨ e₂ , σ ⟩ ⇓ₐ n →
  -----------------
   ⟨ e₁ , σ ⟩ ⇓ₐ n
⟶ₐ-⇓ₐ {.(var X)} {.(const (σ X))} {σ} .{σ X} (var-lookup {X} {σ}) const-eval = var-eval
⟶ₐ-⇓ₐ .{e₁ ⊕ e₂} .{e₁′ ⊕ e₂} {σ} .{n + m} (plus-step₁ {e₁} {e₂} {e₁′} {σ} stp) (plus-eval .{e₁′} .{e₂} .{σ} {n} {m} ev₁ ev₂) = plus-eval (⟶ₐ-⇓ₐ stp ev₁) ev₂
⟶ₐ-⇓ₐ {.(e₁ ⊕ e₂)} {.(e₁ ⊕ e₂′)} {σ} .{n + m} (plus-step₂ {e₁} {e₂} {e₂′} {σ} stp) (plus-eval .{e₁} .{e₂′} .{σ} {n} {m} ev₁ ev₂) = plus-eval ev₁ (⟶ₐ-⇓ₐ stp ev₂)
⟶ₐ-⇓ₐ {.(const n ⊕ const m)} {.(const (n + m))} {σ} {.(n + m)} (plus-step-const {n} {m} {σ}) const-eval = plus-eval const-eval const-eval
⟶ₐ-⇓ₐ .{e₁ - e₂} .{e₁′ - e₂} {σ} .{n ∸ m} (minus-step₁ {e₁} {e₂} {e₁′} {σ} stp) (minus-eval .{e₁′} .{e₂} .{σ} {n} {m} ev₁ ev₂) = minus-eval (⟶ₐ-⇓ₐ stp ev₁) ev₂
⟶ₐ-⇓ₐ {.(e₁ - e₂)} {.(e₁ - e₂′)} {σ} .{n ∸ m} (minus-step₂ {e₁} {e₂} {e₂′} {σ} stp) (minus-eval .{e₁} .{e₂′} .{σ} {n} {m} ev₁ ev₂) = minus-eval ev₁ (⟶ₐ-⇓ₐ stp ev₂)
⟶ₐ-⇓ₐ {.(const n - const m)} {.(const (n ∸ m))} {σ} {.(n ∸ m)} (minus-step-const {n} {m} {σ}) const-eval = minus-eval const-eval const-eval
⟶ₐ-⇓ₐ .{e₁ ⊗ e₂} .{e₁′ ⊗ e₂} {σ} .{n * m} (times-step₁ {e₁} {e₂} {e₁′} {σ} stp) (times-eval .{e₁′} .{e₂} .{σ} {n} {m} ev₁ ev₂) = times-eval (⟶ₐ-⇓ₐ stp ev₁) ev₂
⟶ₐ-⇓ₐ {.(e₁ ⊗ e₂)} {.(e₁ ⊗ e₂′)} {σ} .{n * m} (times-step₂ {e₁} {e₂} {e₂′} {σ} stp) (times-eval .{e₁} .{e₂′} .{σ} {n} {m} ev₁ ev₂) = times-eval ev₁ (⟶ₐ-⇓ₐ stp ev₂)
⟶ₐ-⇓ₐ {.(const n ⊗ const m)} {.(const (n * m))} {σ} {.(n * m)} (times-step-const {n} {m} {σ}) const-eval = times-eval const-eval const-eval

⟶ₐ⋆-⇓ₐ : ∀ {c : AConfig} {n : ℕ} →
   c ⟶ₐ⋆ const n →
  ---------------
      c ⇓ₐ n
⟶ₐ⋆-⇓ₐ step-zero = const-eval
⟶ₐ⋆-⇓ₐ (step-many stp stps) = ⟶ₐ-⇓ₐ stp (⟶ₐ⋆-⇓ₐ stps)


infixr 2 _⟶ₜ⋆_
data _⟶ₜ⋆_ : BConfig → BExpr → Set where
  step-zero : ∀ {b : BExpr}{σ : State} → ⟨ b , σ ⟩ ⟶ₜ⋆ b
  step-many : ∀ {b₁ b₂ b₃ : BExpr} {σ : State} →
    ⟨ b₁ , σ ⟩ ⟶ₜ  b₂ →
    ⟨ b₂ , σ ⟩ ⟶ₜ⋆ b₃ →
    ⟨ b₁ , σ ⟩ ⟶ₜ⋆ b₃

{- THESE SHOULD BE A HW Q -}
⟶ₜ⋆-trans : ∀ {b₁ b₂ b₃ : BExpr} {σ : State} →
  ⟨ b₁ , σ ⟩ ⟶ₜ⋆ b₂ →
  ⟨ b₂ , σ ⟩ ⟶ₜ⋆ b₃ →
  ⟨ b₁ , σ ⟩ ⟶ₜ⋆ b₃
⟶ₜ⋆-trans step-zero stps2 = stps2
⟶ₜ⋆-trans (step-many stp stps1) stps2 = step-many stp (⟶ₜ⋆-trans stps1 stps2)

eq-steps₁ : ∀ {e₁ e₁′ e₂ : AExpr} {σ : State} →
  ⟨ e₁ , σ ⟩ ⟶ₐ⋆ e₁′ →
  ⟨ e₁ == e₂ , σ ⟩ ⟶ₜ⋆ e₁′ == e₂
eq-steps₁ step-zero = step-zero
eq-steps₁ (step-many stp stps) = step-many (eq-step₁ stp) (eq-steps₁ stps)

eq-steps₂ : ∀ {e₁ e₂ e₂′ : AExpr} {σ : State} →
  ⟨ e₂ , σ ⟩ ⟶ₐ⋆ e₂′ →
  ⟨ e₁ == e₂ , σ ⟩ ⟶ₜ⋆ e₁ == e₂′ 
eq-steps₂ step-zero = step-zero
eq-steps₂ (step-many stp stps) = step-many (eq-step₂ stp) (eq-steps₂ stps)

lt-steps₁ : ∀ {e₁ e₁′ e₂ : AExpr} {σ : State} →
  ⟨ e₁ , σ ⟩ ⟶ₐ⋆ e₁′ →
  ⟨ e₁ << e₂ , σ ⟩ ⟶ₜ⋆ e₁′ << e₂
lt-steps₁ step-zero = step-zero
lt-steps₁ (step-many stp stps) = step-many (lt-step₁ stp) (lt-steps₁ stps)

lt-steps₂ : ∀ {e₁ e₂ e₂′ : AExpr} {σ : State} →
  ⟨ e₂ , σ ⟩ ⟶ₐ⋆ e₂′ →
  ⟨ e₁ << e₂ , σ ⟩ ⟶ₜ⋆ e₁ << e₂′ 
lt-steps₂ step-zero = step-zero
lt-steps₂ (step-many stp stps) = step-many (lt-step₂ stp) (lt-steps₂ stps)

not-steps : ∀ {b₁ b₂ : BExpr} {σ : State} →
  ⟨ b₁ , σ ⟩ ⟶ₜ⋆ b₂ →
  ⟨ ! b₁ , σ ⟩ ⟶ₜ⋆ ! b₂
not-steps step-zero = step-zero
not-steps (step-many stp stps) = step-many (not-step stp) (not-steps stps)

and-steps₁ : ∀ {b₁ b₁′ b₂ : BExpr} {σ : State} →
  ⟨ b₁ , σ ⟩ ⟶ₜ⋆ b₁′ →
  ⟨ b₁ && b₂ , σ ⟩ ⟶ₜ⋆ b₁′ && b₂
and-steps₁ step-zero = step-zero
and-steps₁ (step-many stp stps) = step-many (and-step₁ stp) (and-steps₁ stps)

or-steps₁ : ∀ {b₁ b₁′ b₂ : BExpr} {σ : State} →
  ⟨ b₁ , σ ⟩ ⟶ₜ⋆ b₁′ →
  ⟨ b₁ || b₂ , σ ⟩ ⟶ₜ⋆ b₁′ || b₂
or-steps₁ step-zero = step-zero
or-steps₁ (step-many stp stps) = step-many (or-step₁ stp) (or-steps₁ stps)

{- END HW -}

notb : Bool → Bool
notb true = false
notb false = true

andb : Bool → Bool → Bool
andb false b2 = false
andb true b2 = b2

orb : Bool → Bool → Bool
orb false b2 = b2
orb true b2 = true

infixr 2 _⇓ₜ_
data _⇓ₜ_ : BConfig → Bool → Set where
     false-eval : ∀ {σ : State} → ⟨ false , σ ⟩ ⇓ₜ false
     true-eval : ∀ {σ : State} → ⟨ true , σ ⟩ ⇓ₜ true
     eq-eval-true : ∀ {e₁ e₂ : AExpr} {σ : State} {n : ℕ} →
              ⟨ e₁ , σ ⟩ ⇓ₐ n →
              ⟨ e₂ , σ ⟩ ⇓ₐ n →
       ---------------------------
        ⟨ e₁ == e₂ , σ ⟩ ⇓ₜ true
     eq-eval-false : ∀ {e₁ e₂ : AExpr} {σ : State} {n m : ℕ} →
             ⟨ e₁ , σ ⟩ ⇓ₐ n →
             ⟨ e₂ , σ ⟩ ⇓ₐ m →
                  n ≢ m →
       --------------------------
       ⟨ e₁ == e₂ , σ ⟩ ⇓ₜ false
     lt-eval-true : ∀ {e₁ e₂ : AExpr} {σ : State} {n m : ℕ} →
              ⟨ e₁ , σ ⟩ ⇓ₐ n →
              ⟨ e₂ , σ ⟩ ⇓ₐ m →
                       n < m →
       ----------------------------
        ⟨ e₁ << e₂ , σ ⟩ ⇓ₜ true
     lt-eval-false : ∀ {e₁ e₂ : AExpr} {σ : State} {n m : ℕ} →
              ⟨ e₁ , σ ⟩ ⇓ₐ n →
              ⟨ e₂ , σ ⟩ ⇓ₐ m →
                       ¬ (n < m) →
       ----------------------------
        ⟨ e₁ << e₂ , σ ⟩ ⇓ₜ false
     not-eval : ∀ {b : BExpr} {σ : State} {b′ : Bool} → 
          ⟨ b , σ ⟩ ⇓ₜ b′ →
       ------------------------
        ⟨ ! b , σ ⟩ ⇓ₜ notb b′
     and-eval-true : ∀ {b₁ b₂ : BExpr} {σ : State} {b₂′ : Bool} →
              ⟨ b₁ , σ ⟩ ⇓ₜ true →
              ⟨ b₂ , σ ⟩ ⇓ₜ b₂′ →
       ----------------------------------
        ⟨ b₁ && b₂ , σ ⟩ ⇓ₜ b₂′
     and-eval-false : ∀ {b₁ b₂ : BExpr} {σ : State} → 
              ⟨ b₁ , σ ⟩ ⇓ₜ false →
       ----------------------------------
        ⟨ b₁ && b₂ , σ ⟩ ⇓ₜ false
     or-eval-true : ∀ {b₁ b₂ : BExpr} {σ : State} →
              ⟨ b₁ , σ ⟩ ⇓ₜ true →
       ----------------------------------
        ⟨ b₁ || b₂ , σ ⟩ ⇓ₜ true
     or-eval-false : ∀ {b₁ b₂ : BExpr} {σ : State} {b₂′ : Bool} → 
              ⟨ b₁ , σ ⟩ ⇓ₜ false →
              ⟨ b₂ , σ ⟩ ⇓ₜ b₂′ → 
       ----------------------------------
        ⟨ b₁ || b₂ , σ ⟩ ⇓ₜ b₂′ 

and-eval : ∀ {b₁ b₂ : BExpr} {σ : State} {b₁′ b₂′ : Bool} →
  ⟨ b₁ , σ ⟩ ⇓ₜ b₁′ →
  ⟨ b₂ , σ ⟩ ⇓ₜ b₂′ →
  ⟨ b₁ && b₂ , σ ⟩ ⇓ₜ andb b₁′ b₂′
and-eval {b₁} {b₂} {σ} {false} {b₂′} ev₁ ev₂ = and-eval-false ev₁
and-eval {b₁} {b₂} {σ} {true} {b₂′} ev₁ ev₂ = and-eval-true ev₁ ev₂

or-eval : ∀ {b₁ b₂ : BExpr} {σ : State} {b₁′ b₂′ : Bool} →
  ⟨ b₁ , σ ⟩ ⇓ₜ b₁′ →
  ⟨ b₂ , σ ⟩ ⇓ₜ b₂′ →
  ⟨ b₁ || b₂ , σ ⟩ ⇓ₜ orb b₁′ b₂′
or-eval {b₁} {b₂} {σ} {false} {b₂′} ev₁ ev₂ = or-eval-false ev₁ ev₂
or-eval {b₁} {b₂} {σ} {true} {b₂′} ev₁ ev₂ = or-eval-true ev₁


{- This should be a homework question -}

⇓ₜ-⟶ₜ⋆ : ∀ {c : BConfig} {b : Bool} → c ⇓ₜ b → c ⟶ₜ⋆ bool2BExpr b
⇓ₜ-⟶ₜ⋆ false-eval = step-zero
⇓ₜ-⟶ₜ⋆ true-eval = step-zero
⇓ₜ-⟶ₜ⋆ (eq-eval-true ev₁ ev₂) =
   ⟶ₜ⋆-trans (eq-steps₁ (⇓ₐ-⟶ₐ⋆ ev₁))
  (⟶ₜ⋆-trans (eq-steps₂ (⇓ₐ-⟶ₐ⋆ ev₂))
             (step-many eq-step-true step-zero))
⇓ₜ-⟶ₜ⋆ (eq-eval-false ev₁ ev₂ neq) =
   ⟶ₜ⋆-trans (eq-steps₁ (⇓ₐ-⟶ₐ⋆ ev₁))
  (⟶ₜ⋆-trans (eq-steps₂ (⇓ₐ-⟶ₐ⋆ ev₂))
             (step-many (eq-step-false neq) step-zero))
⇓ₜ-⟶ₜ⋆ (lt-eval-true ev₁ ev₂ n<m) =
   ⟶ₜ⋆-trans (lt-steps₁ (⇓ₐ-⟶ₐ⋆ ev₁))
  (⟶ₜ⋆-trans (lt-steps₂ (⇓ₐ-⟶ₐ⋆ ev₂))
             (step-many (lt-step-true n<m) step-zero))
⇓ₜ-⟶ₜ⋆ (lt-eval-false ev₁ ev₂ m≤n) =
   ⟶ₜ⋆-trans (lt-steps₁ (⇓ₐ-⟶ₐ⋆ ev₁))
  (⟶ₜ⋆-trans (lt-steps₂ (⇓ₐ-⟶ₐ⋆ ev₂))
             (step-many (lt-step-false m≤n) step-zero))
⇓ₜ-⟶ₜ⋆ {c} {.(notb false)} (not-eval {_} {_} {false} ev) = ⟶ₜ⋆-trans (not-steps (⇓ₜ-⟶ₜ⋆ ev)) (step-many not-false step-zero)
⇓ₜ-⟶ₜ⋆ {c} {.(notb true)} (not-eval {_} {_} {true} ev) = ⟶ₜ⋆-trans (not-steps (⇓ₜ-⟶ₜ⋆ ev)) (step-many not-true step-zero)
⇓ₜ-⟶ₜ⋆ (and-eval-true ev₁ ev₂) = ⟶ₜ⋆-trans (and-steps₁ (⇓ₜ-⟶ₜ⋆ ev₁)) (step-many and-true (⇓ₜ-⟶ₜ⋆ ev₂))
⇓ₜ-⟶ₜ⋆ (and-eval-false ev₁) = ⟶ₜ⋆-trans (and-steps₁ (⇓ₜ-⟶ₜ⋆ ev₁)) (step-many and-false step-zero)
⇓ₜ-⟶ₜ⋆ (or-eval-true ev) = ⟶ₜ⋆-trans (or-steps₁ (⇓ₜ-⟶ₜ⋆ ev)) (step-many or-true step-zero) 
⇓ₜ-⟶ₜ⋆ (or-eval-false ev₁ ev₂) = ⟶ₜ⋆-trans (or-steps₁ (⇓ₜ-⟶ₜ⋆ ev₁)) (step-many or-false (⇓ₜ-⟶ₜ⋆ ev₂))

⟶ₜ-⇓ₜ : ∀ {b₁ b₂ : BExpr} {σ : State} {b : Bool} → ⟨ b₁ , σ ⟩ ⟶ₜ b₂ → ⟨ b₂ , σ ⟩ ⇓ₜ b → ⟨ b₁ , σ ⟩ ⇓ₜ b
⟶ₜ-⇓ₜ (eq-step₁ stp) (eq-eval-true ev₁ ev₂) = eq-eval-true (⟶ₐ-⇓ₐ stp ev₁) ev₂
⟶ₜ-⇓ₜ (eq-step₁ stp) (eq-eval-false ev₁ ev₂ neq) = eq-eval-false (⟶ₐ-⇓ₐ stp ev₁) ev₂ neq
⟶ₜ-⇓ₜ (eq-step₂ stp) (eq-eval-true ev₁ ev₂) = eq-eval-true ev₁ (⟶ₐ-⇓ₐ stp ev₂)
⟶ₜ-⇓ₜ (eq-step₂ stp) (eq-eval-false ev₁ ev₂ neq) = eq-eval-false ev₁ (⟶ₐ-⇓ₐ stp ev₂) neq
⟶ₜ-⇓ₜ eq-step-true true-eval = eq-eval-true const-eval const-eval
⟶ₜ-⇓ₜ (eq-step-false neq) false-eval = eq-eval-false const-eval const-eval neq
⟶ₜ-⇓ₜ (lt-step₁ stp) (lt-eval-true ev₁ ev₂ n<m) = lt-eval-true (⟶ₐ-⇓ₐ stp ev₁) ev₂ n<m
⟶ₜ-⇓ₜ (lt-step₁ stp) (lt-eval-false ev₁ ev₂ m≤n) = lt-eval-false (⟶ₐ-⇓ₐ stp ev₁) ev₂ m≤n
⟶ₜ-⇓ₜ (lt-step₂ stp) (lt-eval-true ev₁ ev₂ n<m) = lt-eval-true ev₁ (⟶ₐ-⇓ₐ stp ev₂) n<m
⟶ₜ-⇓ₜ (lt-step₂ stp) (lt-eval-false ev₁ ev₂ m≤n) = lt-eval-false ev₁ (⟶ₐ-⇓ₐ stp ev₂) m≤n
⟶ₜ-⇓ₜ (lt-step-true n<m) true-eval = lt-eval-true const-eval const-eval n<m
⟶ₜ-⇓ₜ (lt-step-false m≥n) false-eval = lt-eval-false const-eval const-eval m≥n
⟶ₜ-⇓ₜ (not-step stp) (not-eval ev) = not-eval (⟶ₜ-⇓ₜ stp ev)
⟶ₜ-⇓ₜ {b₁} {b₂} {σ} {false} not-true false-eval = not-eval true-eval
⟶ₜ-⇓ₜ {b₁} {b₂} {σ} {true} not-false true-eval = not-eval false-eval
⟶ₜ-⇓ₜ (and-step₁ stp) (and-eval-true ev₁ ev₂) = and-eval-true (⟶ₜ-⇓ₜ stp ev₁) ev₂
⟶ₜ-⇓ₜ (and-step₁ stp) (and-eval-false ev) = and-eval-false (⟶ₜ-⇓ₜ stp ev)
⟶ₜ-⇓ₜ {true && b₂} {b₂} {σ} {b} and-true ev = and-eval-true true-eval ev
⟶ₜ-⇓ₜ and-false false-eval = and-eval-false false-eval
⟶ₜ-⇓ₜ (or-step₁ stp) (or-eval-true ev) = or-eval-true (⟶ₜ-⇓ₜ stp ev)
⟶ₜ-⇓ₜ (or-step₁ stp) (or-eval-false ev₁ ev₂) = or-eval-false (⟶ₜ-⇓ₜ stp ev₁) ev₂
⟶ₜ-⇓ₜ or-true true-eval = or-eval-true true-eval
⟶ₜ-⇓ₜ or-false ev = or-eval-false false-eval ev

⟶ₜ⋆-⇓ₜ : ∀ {b : BExpr} {σ : State} {b′ : Bool} → ⟨ b , σ ⟩ ⟶ₜ⋆ bool2BExpr b′ → ⟨ b , σ ⟩ ⇓ₜ b′
⟶ₜ⋆-⇓ₜ {.(bool2BExpr false)} {σ} {false} step-zero = false-eval
⟶ₜ⋆-⇓ₜ {.(bool2BExpr true)} {σ} {true} step-zero = true-eval
⟶ₜ⋆-⇓ₜ (step-many stp stps) = ⟶ₜ-⇓ₜ stp (⟶ₜ⋆-⇓ₜ stps)

-- postulate
  -- ⇓ₜ-⟶ₜ⋆ : ∀ {c : BConfig} {b : Bool} → c ⇓ₜ b → c ⟶ₜ⋆ bool2BExpr b
  -- ⟶ₜ-⇓ₜ : ∀ {b₁ b₂ : BExpr} {σ : State} {b : Bool} → ⟨ b₁ , σ ⟩ ⟶ₜ b₂ → ⟨ b₂ , σ ⟩ ⇓ₜ b → ⟨ b₁ , σ ⟩ ⇓ₜ b
  -- ⟶ₜ⋆-⇓ₜ : ∀ {b : BExpr} {σ : State} {b′ : Bool} → ⟨ b , σ ⟩ ⟶ₜ⋆ bool2BExpr b′ → ⟨ b , σ ⟩ ⇓ₜ b′


infixr 2 _⟶ₖ⋆_

data _⟶ₖ⋆_ : Config → Config → Set where
  step-none : ∀ {c : Config} → c ⟶ₖ⋆ c
  step-many : ∀ {c₁ c₂ c₃ : Config} → c₁ ⟶ₖ c₂ → c₂ ⟶ₖ⋆ c₃ → c₁ ⟶ₖ⋆ c₃

⟶ₖ⋆-trans : ∀ {c₁ c₂ c₃ : Config} →
  c₁ ⟶ₖ⋆ c₂ →
  c₂ ⟶ₖ⋆ c₃ →
  ----------
  c₁ ⟶ₖ⋆ c₃
⟶ₖ⋆-trans step-none stps = stps
⟶ₖ⋆-trans (step-many stp stps₁) stps₂ = step-many stp (⟶ₖ⋆-trans stps₁ stps₂)

assgn-steps : ∀ {X : Var} {e₁ e₂ : AExpr} {σ : State} →
  ⟨ e₁ , σ ⟩ ⟶ₐ⋆ e₂ →
  ⟨ X := e₁ , σ ⟩ ⟶ₖ⋆ ⟨ X := e₂ , σ ⟩
assgn-steps step-zero = step-none
assgn-steps (step-many stp stps) = step-many (step-assgn stp) (assgn-steps stps)

seq-steps₁ : ∀ {c₁ c₁′ c₂ : Com} {σ₁ σ₂ : State} →
  ⟨ c₁ , σ₁ ⟩ ⟶ₖ⋆ ⟨ c₁′ , σ₂ ⟩ →
  ⟨ c₁ >> c₂ , σ₁ ⟩ ⟶ₖ⋆ ⟨ c₁′ >> c₂ , σ₂ ⟩
seq-steps₁ step-none = step-none
seq-steps₁ (step-many stp stps) = step-many (step->> stp) (seq-steps₁ stps)

ite-steps : ∀ {b b′ : BExpr} {c₁ c₂ : Com} {σ : State} →
  ⟨ b , σ ⟩ ⟶ₜ⋆ b′ →
  ⟨ ite b c₁ c₂ , σ ⟩ ⟶ₖ⋆ ⟨ ite b′ c₁ c₂ , σ ⟩
ite-steps step-zero = step-none
ite-steps (step-many stp stps) = step-many (step-ite stp) (ite-steps stps) 

infixr 2 _⇓_
  
data _⇓_ : Config → State → Set where
  skip-eval : ∀ {σ : State} →
    ------------------
     ⟨ skip , σ ⟩ ⇓ σ
  assgn-eval : ∀ {X : Var} {e : AExpr} {σ : State} {n : ℕ} →
          ⟨ e , σ ⟩ ⇓ₐ n →
    --------------------------------
     ⟨ X := e , σ ⟩ ⇓ update σ X n 
  seq-eval : ∀ {c₁ c₂ : Com} {σ₁ σ₂ σ₃ : State} →
           ⟨ c₁ , σ₁ ⟩ ⇓ σ₂ →
           ⟨ c₂ , σ₂ ⟩ ⇓ σ₃ →
    ------------------------
     ⟨ c₁ >> c₂ , σ₁ ⟩ ⇓ σ₃
  ite-eval-true : ∀ {b : BExpr} {c₁ c₂ : Com} {σ₁ σ₂ : State} →
        ⟨ b  , σ₁ ⟩ ⇓ₜ true →
        ⟨ c₁ , σ₁ ⟩ ⇓  σ₂ →
    ---------------------------
     ⟨ ite b c₁ c₂ , σ₁ ⟩ ⇓ σ₂
  ite-eval-false : ∀ {b : BExpr} {c₁ c₂ : Com} {σ₁ σ₂ : State} →
        ⟨ b  , σ₁ ⟩ ⇓ₜ false →
        ⟨ c₂ , σ₁ ⟩ ⇓  σ₂ →
    ---------------------------
     ⟨ ite b c₁ c₂ , σ₁ ⟩ ⇓ σ₂
  while-eval-true : ∀ {b : BExpr} {c : Com} {σ₁ σ₂ σ₃ : State} →
    ⟨ b , σ₁ ⟩ ⇓ₜ true →
    ⟨ c , σ₁ ⟩ ⇓ σ₂ →
    ⟨ while b go c , σ₂ ⟩ ⇓ σ₃ →
    ----------------------------------
    ⟨ while b go c , σ₁ ⟩ ⇓ σ₃
  while-eval-false : ∀ {b : BExpr} {c : Com} {σ : State} →
    ⟨ b , σ ⟩ ⇓ₜ false →
    -------------------------
    ⟨ while b go c , σ ⟩ ⇓ σ

⇓-⟶ₖ⋆ : ∀ {c : Com} {σ₁ σ₂ : State} → ⟨ c , σ₁ ⟩ ⇓ σ₂ → ⟨ c , σ₁ ⟩ ⟶ₖ⋆ ⟨ skip , σ₂ ⟩
⇓-⟶ₖ⋆ skip-eval = step-none
⇓-⟶ₖ⋆ (assgn-eval ev) = ⟶ₖ⋆-trans (assgn-steps (⇓ₐ-⟶ₐ⋆ ev)) (step-many assgn-const step-none)
⇓-⟶ₖ⋆ (seq-eval ev₁ ev₂) = ⟶ₖ⋆-trans (seq-steps₁ (⇓-⟶ₖ⋆ ev₁)) (step-many skip->> (⇓-⟶ₖ⋆ ev₂))
⇓-⟶ₖ⋆ (ite-eval-true ev₁ ev₂) = ⟶ₖ⋆-trans (ite-steps (⇓ₜ-⟶ₜ⋆ ev₁)) (step-many ite-true (⇓-⟶ₖ⋆ ev₂))
⇓-⟶ₖ⋆ (ite-eval-false ev₁ ev₂) = ⟶ₖ⋆-trans (ite-steps (⇓ₜ-⟶ₜ⋆ ev₁)) (step-many ite-false (⇓-⟶ₖ⋆ ev₂))
⇓-⟶ₖ⋆ (while-eval-true ev₁ ev₂ ev₃) = ⟶ₖ⋆-trans (step-many step-while (⟶ₖ⋆-trans (ite-steps (⇓ₜ-⟶ₜ⋆ ev₁)) (step-many ite-true step-none))) (⟶ₖ⋆-trans (seq-steps₁ (⇓-⟶ₖ⋆ ev₂)) (step-many skip->> (⇓-⟶ₖ⋆ ev₃)))
⇓-⟶ₖ⋆ (while-eval-false ev) = step-many step-while (⟶ₖ⋆-trans (ite-steps (⇓ₜ-⟶ₜ⋆ ev)) (step-many ite-false step-none))

⟶ₖ-⇓ : ∀ {c₁ c₂ : Config} {σ : State} → c₁ ⟶ₖ c₂ → c₂ ⇓ σ → c₁ ⇓ σ
⟶ₖ-⇓ (step-assgn stp) (assgn-eval ev) = assgn-eval (⟶ₐ-⇓ₐ stp ev)
⟶ₖ-⇓ assgn-const skip-eval = assgn-eval const-eval
⟶ₖ-⇓ (step->> stp) (seq-eval ev₁ ev₂) = seq-eval (⟶ₖ-⇓ stp ev₁) ev₂
⟶ₖ-⇓ skip->> ev = seq-eval skip-eval ev
⟶ₖ-⇓ (step-ite stp) (ite-eval-true ev₁ ev₂) = ite-eval-true (⟶ₜ-⇓ₜ stp ev₁) ev₂
⟶ₖ-⇓ (step-ite stp) (ite-eval-false ev₁ ev₂) = ite-eval-false (⟶ₜ-⇓ₜ stp ev₁) ev₂
⟶ₖ-⇓ ite-true ev = ite-eval-true true-eval ev
⟶ₖ-⇓ ite-false ev = ite-eval-false false-eval ev
⟶ₖ-⇓ step-while (ite-eval-true ev₁ (seq-eval ev₂ ev₃)) = while-eval-true ev₁ ev₂ ev₃
⟶ₖ-⇓ step-while (ite-eval-false ev₁ skip-eval) = while-eval-false ev₁

⟶ₖ⋆-⇓ : ∀ {c : Com} {σ₁ σ₂ : State} → ⟨ c , σ₁ ⟩ ⟶ₖ⋆ ⟨ skip , σ₂ ⟩ → ⟨ c , σ₁ ⟩ ⇓ σ₂
⟶ₖ⋆-⇓ step-none = skip-eval
⟶ₖ⋆-⇓ (step-many stp stps) = ⟶ₖ-⇓ stp (⟶ₖ⋆-⇓ stps)
\end{code}

\section{Introduction to Denotational Semantics}
\label{sec:intr-denot-semant}

\begin{itemize}
\item So far, we have been giving semantics to programming languages in terms of \emph{relations}.
\item However, intuitively what is a program?
  \begin{itemize}
  \item Hint: it's not a relation!
  \item Given an input, a program produces an output.
  \item This sounds more like a function than a relation.
  \end{itemize}
\item The goal of denotational semantics is to find a ``natural'' mathematical object that represents a program.
  \begin{itemize}
  \item What does ``natural'' mean?
  \item Basically, it means intuitive.
  \end{itemize}
\item In the case of \Imp, we will use (partial) functions as our \emph{denotational domain} (collection of mathematical objects that our programs represent).
\item As we will see later in the semester, functions are often ``not good enough''
\end{itemize}

\section{The Denotational Semantics of Expressions}
\label{sec:denot-semant-arithm}

\begin{itemize}
\item An arithmetic expression in \Imp represents a total function from states to natural~numbers.
\item We can easily write an evaluator which, given an expression in some state, returns the number computed by that expression in that state:
  $$
  \llbracket e \rrbracket (\sigma) =
  \left\{\begin{array}{l@{\hspace{2em}\text{if~}}l}
    n & e = \tilde{n}\\
    \sigma(x) & e = x\\
    \llbracket e_1 \rrbracket(\sigma) + \llbracket e_2 \rrbracket(\sigma) & e = e_1 + e_2\\
    \llbracket e_1 \rrbracket(\sigma) - \llbracket e_2 \rrbracket(\sigma) & e = e_1 - e_2\\
    \llbracket e_1 \rrbracket(\sigma) \ast \llbracket e_2 \rrbracket(\sigma) & e = e_1 \ast e_2\\
  \end{array}\right.
  $$
  \begin{itemize}
  \item The choice of blackboard-bold square brackets is traditional.
    In fact, they are sometimes called ``semantic brackets.''
  \item However, in code, we will not use them, since we are writing an evaluator, which also has a traditional notation.
  \item In code:
\begin{code}
evalA : AConfig → ℕ
evalA ⟨ const n , σ ⟩ = n
evalA ⟨ var x , σ ⟩ = σ x
evalA ⟨ e₁ ⊕ e₂ , σ ⟩ = let x = evalA ⟨ e₁ , σ ⟩ in let y = evalA ⟨ e₂ , σ ⟩ in x + y 
evalA ⟨ e₁ - e₂ , σ ⟩ = let x = evalA ⟨ e₁ , σ ⟩ in let y = evalA ⟨ e₂ , σ ⟩ in x ∸ y 
evalA ⟨ e₁ ⊗ e₂ , σ ⟩ = let x = evalA ⟨ e₁ , σ ⟩ in let y = evalA ⟨ e₂ , σ ⟩ in x * y    
\end{code}
  \end{itemize}
\item This is just a uncurried version of our denotational semantics.
  Every arithmetic expression corresponds to a function from states to numbers, just by calling the \textsf{evalA} function:
\begin{code}
denoteA : AExpr → (State → ℕ)
denoteA e σ = evalA ⟨ e , σ ⟩     
\end{code}
\item We now have \emph{three} notions of semantics for arithmetic expressions: the small-step semantics, the big-step semantics, and the denotational semantics.
\item We know that the small- and big-step semantics are the same, but what about the denotational?
\item Again, we have two problems: (1) the denotational semantics could not capture every behavior allowed in the operational semantics, or (2) the denotational semantics could allow more behaviors than the operational semantics.
\item Formally, we can connect the denotational semantics to either the small-step or the big-step semantics.
  We choose the big step.
  \begin{itemize}
  \item We choose big step because it's easier.
    Why is it easier?
  \end{itemize}
\item First, we show that everything the denotational semantics does is allowed in the big-step operational semantics:
  \begin{thm}[AExpr Denotational Soundness]
    If $\llbracket e \rrbracket(\sigma) = n$, then $\langle e, \sigma \rangle \Downarrow n$.
  \end{thm}
  \begin{proof}
    By induction on $e$.

    \noindent\textbf{Cases $e = \tilde{n}$ and $e = x$:}
    These cases are immediate from the definitions.

    \noindent\textbf{Cases $e = e_1 \odot e_2$ where $\odot \in \{+, -, \ast\}$:}
    In these cases, $\llbracket e \rrbracket(\sigma) = \llbracket e_1 \rrbracket(\sigma) \odot \llbracket e_2 \rrbracket(\sigma)$.
    By IH, $\langle e_i , \sigma \rangle \Downarrow \llbracket e_i \rrbracket(\sigma)$.
    By applying the appropriate $\odot$ rule, we get the desired result.
  \end{proof}
\begin{code}
evalA-⇓ₐ : ∀ (c : AConfig) → c ⇓ₐ (evalA c)
evalA-⇓ₐ ⟨ const n , σ ⟩ = const-eval
evalA-⇓ₐ ⟨ var x , σ ⟩ = var-eval
evalA-⇓ₐ ⟨ e₁ ⊕ e₂ , σ ⟩ = plus-eval (evalA-⇓ₐ ⟨ e₁ , σ ⟩) (evalA-⇓ₐ ⟨ e₂ , σ ⟩)
evalA-⇓ₐ ⟨ e₁ - e₂ , σ ⟩ = minus-eval (evalA-⇓ₐ ⟨ e₁ , σ ⟩) (evalA-⇓ₐ ⟨ e₂ , σ ⟩)
evalA-⇓ₐ ⟨ e₁ ⊗ e₂ , σ ⟩ = times-eval (evalA-⇓ₐ ⟨ e₁ , σ ⟩) (evalA-⇓ₐ ⟨ e₂ , σ ⟩)    
\end{code}
\item Second, we show that everything that the only thing that happens in the operational semantics is what the denotational semantics says.
\item One easy way to see this is that our relation for the denotational semantics is ``functional'': if $e \Downarrow n$ and $e \Downarrow m$, then $n = m$.
  Then, the soundness rule above leads to the result that we want.
\item Alternatively, we can prove the completeness result directly and use that to show that $\Downarrow$ is functional.
\item We take the first tactic in English, and the second in agda.
\item The first:
  \begin{thm}[AExpr Big-Step Semantics are Functional]
    For any $e$ and $\sigma$, if $\langle e, \sigma \rangle \Downarrow n$ and $\langle e, \sigma \rangle \Downarrow m$, then $n = m$.
  \end{thm}
  \begin{proof}
    Formally, by induction on $e$.
    Since, for any form of $e$, there is only one rule that can apply, we know that the same rule must be applied in both proofs of $\Downarrow$.
    Applying the inductive hypothesis appropriately, we see that those proofs must be exactly the same and lead to the same result.
  \end{proof}
  \begin{cor}[AExpr Denotational Completeness]
    If $\langle e , \sigma \rangle \Downarrow n$, then $\llbracket e \rrbracket(\sigma) = n$.
  \end{cor}
  \begin{proof}
    We know both that $\langle e, \sigma \rangle \Downarrow n$ and $\langle e , \sigma \rangle \Downarrow \llbracket e \rrbracket(\sigma)$.
    (The second comes from AExpr Denotational Soundness.)
    But then, by the fact that $\Downarrow$ is functional, we get that $n = \llbracket e \rrbracket(\sigma)$ as desired.
  \end{proof}
\item The second:
\begin{code}
⇓ₐ-evalA : ∀ {c : AConfig} {n : ℕ} → c ⇓ₐ n → evalA c ≡ n
⇓ₐ-evalA {⟨ const n , σ ⟩} {n} const-eval = refl
⇓ₐ-evalA {⟨ var X , σ ⟩} {n} var-eval = refl
⇓ₐ-evalA {⟨ e₁ ⊕ e₂ , σ ⟩} {n} (plus-eval ev₁ ev₂)
  rewrite ⇓ₐ-evalA ev₁ | ⇓ₐ-evalA ev₂ = refl
⇓ₐ-evalA {⟨ e₁ - e₂ , σ ⟩} {n} (minus-eval ev₁ ev₂)
  rewrite ⇓ₐ-evalA ev₁ | ⇓ₐ-evalA ev₂ = refl
⇓ₐ-evalA {⟨ e₁ ⊗ e₂ , σ ⟩} {n} (times-eval ev₁ ev₂)
  rewrite ⇓ₐ-evalA ev₁ | ⇓ₐ-evalA ev₂ = refl

⇓ₐ-functional : ∀ {c : AConfig} {n m : ℕ} → c ⇓ₐ n → c ⇓ₐ m → n ≡ m
⇓ₐ-functional {c} {n} {m} ev₁ ev₂ =
  begin
    n
  ≡⟨ sym (⇓ₐ-evalA ev₁) ⟩
    evalA c
  ≡⟨ ⇓ₐ-evalA ev₂ ⟩
    m
  ∎
\end{code}
\item We can pull exactly the same trick for the Boolean expressions.
  We only do it in code here; doing it on paper will be a homework problem:
\begin{code}
evalB : BConfig → Bool
evalB ⟨ true , σ ⟩ = true
evalB ⟨ false , σ ⟩ = false
evalB ⟨ e₁ == e₂ , σ ⟩ = nat-eqb (evalA ⟨ e₁ , σ ⟩) (evalA ⟨ e₂ , σ ⟩)
evalB ⟨ e₁ << e₂ , σ ⟩ = ltb (evalA ⟨ e₁ , σ ⟩) (evalA ⟨ e₂ , σ ⟩)
evalB ⟨ ! b , σ ⟩ = notb (evalB ⟨ b , σ ⟩)
evalB ⟨ b₁ && b₂ , σ ⟩ = andb (evalB ⟨ b₁ , σ ⟩) (evalB ⟨ b₂ , σ ⟩)
evalB ⟨ b₁ || b₂ , σ ⟩ = orb (evalB ⟨ b₁ , σ ⟩) (evalB ⟨ b₂ , σ ⟩)

denoteB : BExpr → (State → Bool)
denoteB b σ = evalB ⟨ b , σ ⟩ 
\end{code}
\newpage
\begin{code}
evalB-⇓ₜ : ∀ (c : BConfig) → c ⇓ₜ (evalB c)
evalB-⇓ₜ ⟨ true , σ ⟩ = true-eval
evalB-⇓ₜ ⟨ false , σ ⟩ = false-eval
evalB-⇓ₜ ⟨ e₁ == e₂ , σ ⟩ with (evalA ⟨ e₁ , σ ⟩) ≟ (evalA ⟨ e₂ , σ ⟩)
... | yes eq rewrite nat-eqb-equal eq = eq-eval-true (evalA-⇓ₐ ⟨ e₁ , σ ⟩ ) ev
    where
      ev : ⟨ e₂ , σ ⟩ ⇓ₐ evalA ⟨ e₁ , σ ⟩
      ev rewrite eq = evalA-⇓ₐ ⟨ e₂ , σ ⟩
... | no neq rewrite nat-eqb-nequal neq = eq-eval-false (evalA-⇓ₐ ⟨ e₁ , σ ⟩) (evalA-⇓ₐ ⟨ e₂ , σ ⟩) neq
evalB-⇓ₜ ⟨ e₁ << e₂ , σ ⟩ with (evalA ⟨ e₁ , σ ⟩) <? (evalA ⟨ e₂ , σ ⟩ )
... | yes pf rewrite <-ltb pf = lt-eval-true (evalA-⇓ₐ ⟨ e₁ , σ ⟩) (evalA-⇓ₐ ⟨ e₂ , σ ⟩) pf
... | no pf rewrite ≮-ltb pf = lt-eval-false (evalA-⇓ₐ ⟨ e₁ , σ ⟩) (evalA-⇓ₐ ⟨ e₂ , σ ⟩) pf 
evalB-⇓ₜ ⟨ ! b , σ ⟩ = not-eval (evalB-⇓ₜ ⟨ b , σ ⟩) 
evalB-⇓ₜ ⟨ b₁ && b₂ , σ ⟩ = and-eval (evalB-⇓ₜ ⟨ b₁ , σ ⟩) (evalB-⇓ₜ ⟨ b₂ , σ ⟩) 
evalB-⇓ₜ ⟨ b₁ || b₂ , σ ⟩ = or-eval (evalB-⇓ₜ ⟨ b₁ , σ ⟩) (evalB-⇓ₜ ⟨ b₂ , σ ⟩)

evalB-≡-⇓ₜ : ∀ {c : BConfig} {b : Bool} → evalB c ≡ b → c ⇓ₜ b
evalB-≡-⇓ₜ {c} {b} eq rewrite (sym eq) = evalB-⇓ₜ c 

⇓ₜ-evalB : ∀ {c : BConfig} {b : Bool} → c ⇓ₜ b → evalB c ≡ b
⇓ₜ-evalB {⟨ false , σ ⟩} {b} false-eval = refl
⇓ₜ-evalB {⟨ true , σ ⟩} {b} true-eval = refl
⇓ₜ-evalB {⟨ e₁ == e₂ , σ ⟩} {true} (eq-eval-true {e₁} {e₂} {σ} {n} ev₁ ev₂)
  rewrite ⇓ₐ-evalA ev₁ | ⇓ₐ-evalA ev₂ = nat-eqb-refl {n}
⇓ₜ-evalB {⟨ e₁ == e₂ , σ ⟩} {false} (eq-eval-false {e₁} {e₂} {σ} {n} {m} ev₁ ev₂ neq)
  rewrite ⇓ₐ-evalA ev₁ | ⇓ₐ-evalA ev₂ = nat-eqb-nequal neq
⇓ₜ-evalB {⟨ e₁ << e₂ , σ ⟩} {true} (lt-eval-true {e₁} {e₂} {σ} {n} {m} ev₁ ev₂ n<m)
  rewrite ⇓ₐ-evalA ev₁ | ⇓ₐ-evalA ev₂ = <-ltb n<m
⇓ₜ-evalB {⟨ e₁ << e₂ , σ ⟩} {b} (lt-eval-false {e₁} {e₂} {σ} {n} {m} ev₁ ev₂ n≮m)
  rewrite ⇓ₐ-evalA ev₁ | ⇓ₐ-evalA ev₂ = ≮-ltb n≮m
⇓ₜ-evalB {⟨ ! b , σ ⟩ } {_} (not-eval ev) = cong notb (⇓ₜ-evalB ev)
⇓ₜ-evalB {⟨ b₁ && b₂ , σ ⟩} {b} (and-eval-true ev₁ ev₂)
  rewrite ⇓ₜ-evalB ev₁ = ⇓ₜ-evalB ev₂
⇓ₜ-evalB {⟨ b₁ && b₂ , σ ⟩} {false} (and-eval-false ev)
  rewrite ⇓ₜ-evalB ev = refl
⇓ₜ-evalB {⟨ b₁ || b₂ , σ ⟩} {b} (or-eval-true ev)
  rewrite ⇓ₜ-evalB ev = refl
⇓ₜ-evalB {⟨ b₁ || b₂ , σ ⟩} {b} (or-eval-false ev₁ ev₂)
  rewrite ⇓ₜ-evalB ev₁ = ⇓ₜ-evalB ev₂

⇓ₜ-functional : ∀ {c : BConfig} {b₁ b₂ : Bool} → c ⇓ₜ b₁ → c ⇓ₜ b₂ → b₁ ≡ b₂
⇓ₜ-functional {c} {b₁} {b₂} ev₁ ev₂ =
  begin
    b₁
  ≡⟨ sym (⇓ₜ-evalB ev₁) ⟩
    evalB c
  ≡⟨ ⇓ₜ-evalB ev₂ ⟩
    b₂
  ∎    
\end{code}
\end{itemize}

\newpage
\section{The Denotational Semantics of Commands}
\label{sec:denot-semant-comm}

\begin{itemize}
\item Now we turn to the difficult part: the denotational semantics of commands.
\item Unlike expressions, \Imp commands do \emph{not} correspond to (total) functions.
\item To see why, consider the following program, which we'll call $c$:
  $$\begin{array}{l}
    i := 0;\\
    \textsf{while}~\itrue~\textsf{do}\\
    ~~i := i + 1
  \end{array}$$
\item Imagine that we model $\llbracket c \rrbracket$ as a function on states.
  What's $\llbracket c \rrbracket(\sigma)$ (for your favorite start state $\sigma$, say $\sigma(x) = 0$ for all $x$)?
  There's no possible answer.
\item Instead, we need to move to \emph{partial}~functions.
  \begin{itemize}
  \item \item A partial function~$f$ is like a function, but it can fail to return: every input $x$ has \emph{at most} one output $f(x)$, but $f(x)$ may be \emph{undefined}.
  \item We often write $f(x) = \bot$ to mean that $f(x)$ is undefined.
    In the literature on computability theory, they often write $f(x)\uparrow$ to mean $f(x)$ is undefined, and $f(x)\downarrow$ to mean it \emph{is} defined.
    In this class, we will use the first convention.
  \end{itemize}
\item One sad aspect about moving to partial functions: we can no longer use agda.
\item In agda, every program must terminate.
  \begin{itemize}
  \item Otherwise, you could write the following:
    \begin{tabular}{l}
      \textsf{uh-oh : ⊥}\\
      \textsf{uh-oh = uh-oh}
    \end{tabular}
  \item This code is an infinite loop, but would be perfectly valid (if useless) in e.g., ocaml.
  \item In agda, though, it would mean we can prove false, which we don't want to be able to do!
  \end{itemize}
\item Therefore, we will have to do everything on paper.
\item Here are the denotational semantics of \Imp:
  $$
  \llbracket c \rrbracket(\sigma) =
  \left\{\begin{array}{l@{\hspace{2em}\text{if~}}l}
      \sigma & c = \Skip\\
      \sigma[X \mapsto n] & c = X := e \mathrel{\text{and}} \llbracket e \rrbracket(\sigma) = n\\
      \llbracket c_2 \rrbracket(\llbracket c_1\rrbracket(\sigma)) & c = c_1; c_2\\
      \llbracket c_1 \rrbracket(\sigma) & c = \ite{b}{c_1}{c_2} \mathrel{\text{and}} \llbracket b \rrbracket(\sigma) = \itrue\\
    \llbracket c_2 \rrbracket(\sigma) & c = \ite{b}{c_1}{c_2} \mathrel{\text{and}} \llbracket b \rrbracket(\sigma) = \ifalse\\
    \text{fix}(\Gamma) & c = \while{b}{c'}
    \end{array}\right.
  $$
  where $$\Gamma(f)(\sigma) =
  \left\{\begin{array}{l@{\hspace{2em}\text{if~}}l}
    f(\llbracket c \rrbracket(\sigma)) & \llbracket b \rrbracket(\sigma) = \itrue\\
    \sigma & \llbracket b \rrbracket(\sigma) = \ifalse\\
  \end{array}\right.$$
\begin{itemize}
\item What is this mysterious ``fix'' thing?
\item It gives the \emph{least fixed point} of $\Gamma$.
\item For a function $\Gamma : A \to A$, a \emph{fixed point} of $\Gamma$ is an $x : A$ such that $\Gamma(x) = x$.
\item In our case, $\Gamma : (\textsf{State} \to \textsf{State}) \to \textsf{State} \to \textsf{State}$, so any first point of $\Gamma$ has the right type.
\item We want the \emph{least} fix point, which has the property that for any fixed point $f$ of $\Gamma$, if $\text{fix}(\Gamma)(\sigma) = \sigma'$, then $f(\sigma) = \sigma'$.
  \begin{itemize}
  \item So if we consider the graph $\text{graph}(f) = \{ (x, f(x)) | x \in A \}$, then
    $\text{graph}(\text{fix}(\Gamma)) \subseteq \text{graph}(f)$
  \end{itemize}
\item Why is $\text{fix}(\Gamma)$ the ``right thing''?
\item Let's look at what $\Gamma$ does: if $b$ is true in the current state, it runs $c$ and then continues as $f$.
  Otherwise, it just returns $\sigma$.
\item In a fixpoint, $f = \text{fix}(\Gamma)$, which is the semantics of the loop.
  So after running $c$ once, it goes back to the beginning of the loop.
\item This is exactly the semantics we're looking for!
\end{itemize}
\item \textbf{Stop and Think:} Where does the partiality come in?
\item From the fixpoint! 
  For example, if $b = \itrue$, then the least fixed point of $\Gamma$ is the function that never returns.
  \begin{itemize}
  \item Let's check that it is indeed a fixpoint:
    $$\forall \sigma.\;\Gamma(\lambda x.\,\bot)(\sigma) = (\lambda x. \bot)(\llbracket c \rrbracket(\sigma)) = \bot = (\lambda x.\,\bot)(\sigma)$$
    where the first equation comes from the fact that $\llbracket \itrue \rrbracket(\sigma) = \itrue$.
    So, indeed they are the same.
  \item For any other fixpoint~$f$ and states~$\sigma$ and~$\sigma'$, if $(\lambda x.\, \bot)(\sigma) = \sigma'$ then $f(\sigma) = \sigma'$ vacuously, since $(\lambda x.\,\bot)(\sigma)$ is never defined.
  \item Thus, the never-returning function is the least fixed point of $\Gamma$.
  \end{itemize}
\item Notation: for $f : A \to A$, we write
  \begin{mathpar}
    f^0(x) = x \and
    f^{(\textsf{suc}(n))}(x) = f(f^{n}(x))
  \end{mathpar}
\end{itemize}

\begin{thm}[Com Denotational Soundness]
  For any command~$c$ and states~$\sigma_1$ and $\sigma_2$, if $\langle c, \sigma_1 \rangle \Downarrow \sigma_2$ then $\llbracket c \rrbracket(\sigma_1) = \sigma_2$.
\end{thm}
\begin{proof}
  By induction on $c$.

  \noindent\textbf{Case $c = \Skip$:}
  In this case, the only possible proof of $\langle \Skip , \sigma_1 \rangle \Downarrow \sigma_2$ is from the \textsc{skip}~rule, which forces $\sigma_2 = \sigma_1$.
  Additionally $\llbracket \Skip \rrbracket(\sigma_1) = \sigma_1 = \sigma_2$, so we're done.

  \noindent\textbf{Case $c = X := e$:}
  In this case, the only possible proof of $\langle X := e , \sigma_1 \rangle \Downarrow \sigma_2$ is from the \textsc{assign}~rule, which forces $\sigma_2 = \sigma_1[X \mapsto n]$ where $\langle e, \sigma_1 \rangle \Downarrow n$.
  By soundness and completeness of the denotational semantics of expressions, $\llbracket e \rrbracket(\sigma_1) = n$ if there is such a proof, and there must be such a proof because $\llbracket e \rrbracket$ is total.
  But the $\llbracket X := e \rrbracket(\sigma_1) = \sigma_1[X \mapsto \llbracket e \rrbracket(\sigma_1)]$, which is exactly what we wanted.

  \noindent\textbf{Case $c = c_1; c_2$:}
  The only possible proof of $\langle c_1; c_2, \sigma_1 \rangle \Downarrow \sigma_2$ comes from \textsc{seq}, which means we know that there is some $\sigma$ such that $\langle c_1, \sigma_1 \rangle \Downarrow \sigma$ and $\langle c_2, \sigma \rangle \Downarrow \sigma_2$.
  By IH, we know that $\llbracket c_1 \rrbracket(\sigma_1) = \sigma$ and $\llbracket c_2 \rrbracket(\sigma) = \sigma_2$.
  But then $$\llbracket c_1; c_2 \rrbracket(\sigma_1) = \llbracket c_2 \rrbracket(\llbracket c_1 \rrbracket(\sigma_1)) = \llbracket c_2 \rrbracket(\sigma) = \sigma_2$$ as desired.

  \noindent\textbf{Case $c = \ite{b}{c_1}{c_2}$:}
  We know from previous theorems that $\langle b, \sigma_1 \rangle \Downarrow b'$ if and only if $b' = \llbracket b \rrbracket(\sigma_1)$, and from the IH that $\langle c_i, \sigma_1 \rangle \Downarrow \sigma_2$ iff $\llbracket c_i \rrbracket(\sigma_1) = \sigma_2$ for $i=1,2$.
  The proof of $\langle\ite{b}{c_1}{c_2}, \sigma_1\rangle \Downarrow \sigma_2$ can come from either \textsc{ite-true} or \textsc{ite-false}.
  Either way, we can use the facts above to prove the desired result.

  \noindent\textbf{Case $c = \while{b}{c'}$:}
  In this case, the proof of $\langle \while{b}{c'}, \sigma_1 \rangle \Downarrow \sigma_2$ could be proven by either the \textsc{while-true} or \textsc{while-false} rules.
  In the case of the \textsc{while-false}~rule, we get that $\langle b, \sigma_1 \rangle \Downarrow \ifalse$ and thus $\llbracket b \rrbracket(\sigma_1) = \ifalse$.
      Hence, we get:
  $$(\text{fix}(\Gamma))(\sigma_1) = \Gamma(\text{fix}(\Gamma))(\sigma_1) = \sigma_1$$
  where the second equation comes straight from the definition of $\Gamma$.
  But this is exactly what we wanted to prove.
  In the case of the \textsc{while-true}~rule, we know that $\langle b, \sigma_1 \rangle \Downarrow \itrue$, $\langle c ,\sigma_1 \rangle \Downarrow \sigma$, and $\langle \while{b}{c'}, \sigma \rangle \Downarrow \sigma_2$ for some $\sigma$.
  Hence, we know all of:
  \begin{mathpar}
    \llbracket b \rrbracket(\sigma_1) = \itrue \and \llbracket c' \rrbracket(\sigma_1) = \sigma \and \llbracket \while{b}{c'} \rrbracket(\sigma) = \sigma_2
  \end{mathpar}
  In addition, we have:
  $$(\text{fix}(\Gamma))(\sigma_1) = \Gamma(\text{fix}(\Gamma))(\sigma_1) = (\text{fix}(\Gamma))(\llbracket c \rrbracket(\sigma_1)) = (\text{fix}(\Gamma))(\sigma) = \sigma_2$$
  as desired.
\end{proof}

Observe that $\Downarrow$ for commands is functional.
Thus, we also get the following corrolary:

\begin{cor}[Denotational Completeness for Commands]
  If $\llbracket c \rrbracket(\sigma_1) = \sigma_2$, then $\langle c, \sigma_1 \rangle \Downarrow \sigma_2$.
\end{cor}
\begin{proof}
  We know from above that if $\langle c, \sigma_1 \rangle \Downarrow \sigma$ for any state $\sigma$, then $\llbracket c \rrbracket(\sigma_1) = \sigma$.
  So the only thing we have to prove is that there is no $c$ and $\sigma_1$ such that $\llbracket c \rrbracket(\sigma_1)$ is defined, but there is no $\sigma$ such that $\langle c, \sigma_1 \rangle \Downarrow \sigma$.
  The only place where this can possibly come up is in the semantics of $\while{b}{c}$.
  Since $\llbracket \while{b}{c} \rrbracket(\sigma)$ is defined, it is equal to $\llbracket c \rrbracket^n(\sigma)$ for some finite $n$.
  But then we can use $n$ applications of the \textsc{while-true} rule to get the desired result.
\end{proof}


\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% TeX-engine: luatex
%%% TeX-command-default: "Make"
%%% End:
