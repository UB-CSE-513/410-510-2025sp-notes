\documentclass{lecturenotes}

\usepackage[colorlinks,urlcolor=blue]{hyperref}
\usepackage{doi}
\usepackage{xspace}
\usepackage{agda}
\usepackage{fontspec}
\usepackage{enumerate}
\usepackage{mathpartir}
\usepackage{pl-syntax/pl-syntax}
\usepackage{forest}
\usepackage{stmaryrd}

\setsansfont{Fira Code}
\usepackage{newunicodechar}
\newunicodechar{∣}{\ensuremath{\mid}}
\newunicodechar{′}{\ensuremath{{}^\prime}}
\newunicodechar{ˡ}{\ensuremath{{}^{\textsf{l}}}}
\newunicodechar{ʳ}{\ensuremath{{}^{\textsf{r}}}}
\newunicodechar{≤}{\ensuremath{\mathord{\leq}}}
\newunicodechar{≡}{\ensuremath{\mathord{\equiv}}}
\newunicodechar{≐}{\ensuremath{\mathord{\doteq}}}
\newunicodechar{∘}{\ensuremath{\circ}}
\newunicodechar{≃}{\ensuremath{\simeq}}
\newunicodechar{≲}{\ensuremath{\precsim}}
\newunicodechar{⊎}{\ensuremath{\uplus}}
\newunicodechar{≟}{\ensuremath{\stackrel{?}{=}}}
\newunicodechar{̬}{\ensuremath{{}_{\textsf{v}}}}
\newunicodechar{ₐ}{\ensuremath{{}_{\textsf{a}}}}
\newunicodechar{ₜ}{\ensuremath{{}_{\textsf{t}}}}
\newunicodechar{ₖ}{\ensuremath{{}_{\textsf{k}}}}
\newunicodechar{₁}{\ensuremath{{}_{1}}}
\newunicodechar{₂}{\ensuremath{{}_{2}}}
\newunicodechar{₃}{\ensuremath{{}_{3}}}
\newunicodechar{⊕}{\ensuremath{\oplus}}
\newunicodechar{⊗}{\ensuremath{\otimes}}
\newunicodechar{σ}{\ensuremath{\sigma}}
\newunicodechar{∸}{\ensuremath{\stackrel{.}{-}}}
\newunicodechar{≮}{\ensuremath{\not<}}
\newunicodechar{⋆}{\ensuremath{{}^{\ast}}}
\newunicodechar{⇓}{\ensuremath{\Downarrow}}
\newunicodechar{⇒}{\ensuremath{\implies}}

\newcommand{\Imp}{\textsc{Imp}\xspace}
\newcommand{\Skip}{\textsf{skip}}
\newcommand{\ite}[3]{\ensuremath{\textsf{if}\mkern5mu#1 \mathrel{\textsf{then}} #2 \mathrel{\textsf{else}} #3}}
\newcommand{\while}[2]{\ensuremath{\textsf{while}\mkern5mu#1 \mathrel{\textsf{do}} #2}}
\newcommand{\itrue}{\textsf{true}}
\newcommand{\ifalse}{\textsf{false}}

\newcommand{\astep}{\ensuremath{\mathrel{\longrightarrow_a}}}
\newcommand{\bstep}{\ensuremath{\mathrel{\longrightarrow_b}}}
\newcommand{\cstep}{\ensuremath{\mathrel{\longrightarrow_c}}}

\newcommand{\hoare}[3]{\ensuremath{\{#1\}\mkern4mu#2\mkern4mu\{#3\}}}

\title{Axiomatic Semantics}
\coursenumber{CSE 410/510}
\coursename{Programming Language Theory}
\lecturenumber{12}
\semester{Spring 2025}
\professor{Professor Andrew K. Hirsch}

\begin{document}
\maketitle

\begin{code}[hide]
module lec12-akh where

import Relation.Binary.PropositionalEquality as Eq
open Eq using (_≡_; _≢_; refl; cong; sym)
open Eq.≡-Reasoning
open import Data.Nat using (ℕ; zero; suc; _+_; _*_; _∸_; _<_; z<s; s<s; _≤_; _>_)
open import Data.Product using (_×_; proj₁; proj₂) renaming (_,_ to ⟨_,_⟩)
open import Data.Bool using (Bool; true; false; if_then_else_)
open import Relation.Nullary using (Dec; yes; no; ¬_)

postulate
  Var : Set
  _≟̬_ : ∀ (X Y : Var) → Dec (X ≡ Y)

_≟_ : ∀ (n m : ℕ) → Dec (n ≡ m)
zero ≟ zero = yes refl
zero ≟ (suc m) = no λ ()
(suc n) ≟ zero = no λ ()
(suc n) ≟ (suc m) with n ≟ m
... | yes eq  = yes (cong suc eq)
... | no neq = no (λ {refl -> neq refl}) 

nat-eqb : ∀ (n m : ℕ) → Bool
nat-eqb zero zero = true
nat-eqb zero (suc _) = false
nat-eqb (suc _) zero = false
nat-eqb (suc n) (suc m) = nat-eqb n m

nat-eqb-true : ∀ {n m : ℕ} → nat-eqb n m ≡ true → n ≡ m
nat-eqb-true {zero} {zero} eqbnm≡true = refl
nat-eqb-true {suc n} {suc m} eqbnm≡true  = cong suc (nat-eqb-true {n} {m} eqbnm≡true)

neq-suc′ : ∀ {n m : ℕ} → suc n ≢ suc m → n ≢ m
neq-suc′ {n} {m} neq = λ eq → neq (cong suc eq)

suc-eq : ∀ {n m : ℕ} → suc n ≡ suc m → n ≡ m
suc-eq refl = refl

neq-suc : ∀ {n m : ℕ} → n ≢ m → suc n ≢ suc m
neq-suc {n} {m} neq = λ {eq → neq (suc-eq eq)} 

nat-eqb-false : ∀ {n m : ℕ} → nat-eqb n m ≡ false → n ≢ m
nat-eqb-false {zero} {suc m} eqbnm≡false = λ ()
nat-eqb-false {suc n} {zero} eqbnm≡false = λ () 
nat-eqb-false {suc n} {suc m} eqbnm≡false = neq-suc (nat-eqb-false {n} {m} eqbnm≡false)

nat-eqb-equal : ∀ {n m : ℕ} → n ≡ m → nat-eqb n m ≡ true
nat-eqb-equal {zero} {zero} eq = refl
nat-eqb-equal {suc n} {suc m} eq = nat-eqb-equal (suc-eq eq)

nat-eqb-refl : ∀ {n : ℕ} → nat-eqb n n ≡ true
nat-eqb-refl {zero} = refl
nat-eqb-refl {suc n} = nat-eqb-refl {n}

nat-eqb-nequal : ∀ {n m : ℕ} → n ≢ m → nat-eqb n m ≡ false
nat-eqb-nequal {zero} {zero} neq with (neq refl)
... | () 
nat-eqb-nequal {zero} {suc m} neq = refl
nat-eqb-nequal {suc n} {zero} neq = refl
nat-eqb-nequal {suc n} {suc m} neq = nat-eqb-nequal (neq-suc′ neq)

_≟ₜ_ : ∀ (b₁ b₂ : Bool) → Dec (b₁ ≡ b₂)
false ≟ₜ false = yes refl
false ≟ₜ true = no λ ()
true ≟ₜ false = no λ ()
true ≟ₜ true = yes refl

_<?_ : (n m : ℕ) → Dec (n < m)
zero <? zero = no λ ()
zero <? suc m = yes z<s
suc n <? zero = no λ ()
suc n <? suc m with n <? m
... | yes n<m = yes (s<s n<m)
... | no n≮m = no (λ {(s<s pf) → n≮m pf}) 

ltb : ℕ → ℕ → Bool
ltb zero zero = false
ltb zero (suc _) = true
ltb (suc m) zero = false
ltb (suc m) (suc n) = ltb m n

ltb-true : ∀ {m n : ℕ} → ltb m n ≡ true → m < n
ltb-true {zero} {suc n} m<?n≡true = z<s
ltb-true {suc m} {suc n} m<?n≡true = s<s (ltb-true m<?n≡true)

<-ltb : ∀ {m n : ℕ} → m < n → ltb m n ≡ true
<-ltb {zero} {suc n} m<n = refl
<-ltb {suc m} {suc n} (Data.Nat.s≤s m<n) = <-ltb {m} {n} m<n

≮-ltb : ∀ {n m : ℕ} → ¬ (n < m) → ltb n m ≡ false
≮-ltb {zero} {zero} n≮m = refl
≮-ltb {zero} {suc m} n≮m with n≮m z<s
... | ()
≮-ltb {suc n} {zero} n≮m = refl
≮-ltb {suc n} {suc m} n≮m = ≮-ltb {n} {m} λ n<m → n≮m (s<s n<m)

data AExpr : Set where
  const : ℕ → AExpr
  var : Var → AExpr
  _⊕_ : AExpr → AExpr → AExpr
  _-_ : AExpr → AExpr → AExpr
  _⊗_ : AExpr → AExpr → AExpr

infixr 5 _⊕_
infixr 5 _-_
infixr 4 _⊗_

data BExpr : Set where
  true : BExpr
  false : BExpr
  _==_ : AExpr → AExpr → BExpr
  _<<_ : AExpr → AExpr → BExpr
  !_ : BExpr → BExpr
  _&&_ : BExpr → BExpr → BExpr
  _||_ : BExpr → BExpr → BExpr

infixr 3 _&&_
infixr 3 _||_

bool2BExpr : Bool → BExpr
bool2BExpr true = true
bool2BExpr false = false

data Com : Set where
  skip : Com
  _:=_ : Var → AExpr → Com
  _>>_ : Com → Com → Com
  ite : BExpr → Com → Com → Com
  while_go_ : BExpr → Com → Com


infixr 2 _⟶ₐ_

State = Var → ℕ

update : State → Var → ℕ → State
update σ X n Y with X ≟̬ Y
... | yes _ = n
... | no _ = σ Y 

AConfig = AExpr × State

-- note: this is a long arrow \-->
data _⟶ₐ_ : AConfig → AExpr → Set where
  var-lookup : ∀ {X : Var} {σ : State} →
    ⟨ var X , σ ⟩ ⟶ₐ const (σ X)
  plus-step₁ : ∀ {x y z : AExpr}{σ : State} →
         ⟨ x , σ ⟩ ⟶ₐ z →
    ------------------------
     ⟨ x ⊕ y , σ ⟩ ⟶ₐ z ⊕ y
  plus-step₂ : ∀ {x y z : AExpr} {σ : State}→
         ⟨ y , σ ⟩ ⟶ₐ z →
    ------------------------
     ⟨ x ⊕ y , σ ⟩ ⟶ₐ x ⊕ z
  plus-step-const : ∀ {n m : ℕ} {σ : State} →
    ------------------------------------------------
     ⟨ (const n) ⊕ (const m) , σ ⟩ ⟶ₐ const (n + m)
  minus-step₁ : ∀ {x y z : AExpr}{σ : State} →
         ⟨ x , σ ⟩ ⟶ₐ z →
    ------------------------
     ⟨ x - y , σ ⟩ ⟶ₐ z - y
  minus-step₂ : ∀ {x y z : AExpr} {σ : State} →
         ⟨ y , σ ⟩ ⟶ₐ z →
    ------------------------
     ⟨ x - y , σ ⟩ ⟶ₐ x - z
  minus-step-const : ∀ {n m : ℕ} {σ : State} →
    ------------------------------------------------
     ⟨ (const n) - (const m) , σ ⟩ ⟶ₐ const (n ∸ m) 
  times-step₁ : ∀ {x y z : AExpr} {σ : State} →
         ⟨ x , σ ⟩ ⟶ₐ z →
    ------------------------
     ⟨ x ⊗ y , σ ⟩ ⟶ₐ z ⊗ y
  times-step₂ : ∀ {x y z : AExpr} {σ : State} →
         ⟨ y , σ ⟩ ⟶ₐ z →
    ------------------------
     ⟨ x ⊗ y , σ ⟩ ⟶ₐ x ⊗ z
  times-step-const : ∀ {n m : ℕ} {σ : State} →
    ------------------------------------------------
     ⟨ (const n) ⊗ (const m) , σ ⟩ ⟶ₐ const (n * m)

BConfig = BExpr × State

infixr 2 _⟶ₜ_
data _⟶ₜ_ : BConfig → BExpr → Set where
  eq-step₁ : ∀ {x y z : AExpr} {σ : State} →
          ⟨ x , σ ⟩ ⟶ₐ z → 
    --------------------------
     ⟨ x == y , σ ⟩ ⟶ₜ z == y
  eq-step₂ : ∀ {x y z : AExpr} {σ : State} →
          ⟨ y , σ ⟩ ⟶ₐ z →
    --------------------------
     ⟨ x == y , σ ⟩ ⟶ₜ x == z
  eq-step-true : ∀ {n : ℕ} {σ : State} →
    ------------------------------------------------------
     ⟨ (const n) == (const n) , σ ⟩ ⟶ₜ true
  eq-step-false : ∀ {n m : ℕ} {σ : State} →
                    n ≢ m ->
    ----------------------------------------
    ⟨ (const n) == (const m) , σ ⟩ ⟶ₜ false
  lt-step₁ : ∀ {x y z : AExpr} {σ : State} →
          ⟨ x , σ ⟩ ⟶ₐ z →
    --------------------------
     ⟨ x << y , σ ⟩ ⟶ₜ z << y 
  lt-step₂ : ∀ {x y z : AExpr} {σ : State} →
          ⟨ y , σ ⟩ ⟶ₐ z →
    --------------------------
     ⟨ x << y , σ ⟩ ⟶ₜ x << z
  lt-step-true : ∀ {n m : ℕ} {σ : State} →
                                  n < m →
    ---------------------------------------------------------
     ⟨ (const n) << (const m) , σ ⟩ ⟶ₜ true
  lt-step-false : ∀ {n m : ℕ} {σ : State} →
                                 ¬ (n < m) → 
    ---------------------------------------------------------
     ⟨ (const n) << (const m) , σ ⟩ ⟶ₜ false

  not-step : ∀ {b₁ b₂ : BExpr} {σ : State} →
       ⟨ b₁ , σ ⟩ ⟶ₜ b₂ →
    ----------------------
     ⟨ ! b₁ , σ ⟩ ⟶ₜ ! b₂
  not-true : ∀ {σ : State} →
    -------------------------
     ⟨ ! true , σ ⟩ ⟶ₜ false
  not-false : ∀ {σ : State} → 
    -----------------
     ⟨ ! false , σ ⟩ ⟶ₜ true
  and-step₁ : ∀ {b₁ b₂ b₃ : BExpr} {σ : State} →
           ⟨ b₁ , σ ⟩ ⟶ₜ b₃ →
    ------------------------------
     ⟨ b₁ && b₂ , σ ⟩ ⟶ₜ b₃ && b₂
  and-true : ∀ {b₂ : BExpr} {σ : State} →
    --------------------------
     ⟨ true && b₂ , σ ⟩ ⟶ₜ b₂
  and-false : ∀ {b₂ : BExpr} {σ : State} →
    ------------------------------
     ⟨ false && b₂ , σ ⟩ ⟶ₜ false
  or-step₁ : ∀ {b₁ b₂ b₃ : BExpr} {σ : State} →
           ⟨ b₁ , σ ⟩ ⟶ₜ b₃ →
    ------------------------------
     ⟨ b₁ || b₂ , σ ⟩ ⟶ₜ b₃ || b₂
  or-true : ∀ {b₂ : BExpr} {σ : State}→
    ----------------------------
     ⟨ true || b₂ , σ ⟩ ⟶ₜ true
  or-false : ∀ {b₂ : BExpr} {σ : State} →
    ---------------------------
     ⟨ false || b₂ , σ ⟩ ⟶ₜ b₂

Config = Com × State

infixr 2 _⟶ₖ_
data _⟶ₖ_ : Config → Config → Set where
  step-assgn : ∀ {X : Var} {e₁ e₂ : AExpr} {σ : State} →
          ⟨ e₁ , σ ⟩ ⟶ₐ e₂ →
    ------------------------------------
     ⟨ X := e₁ , σ ⟩ ⟶ₖ ⟨ X := e₂ , σ ⟩
  assgn-const : ∀ {X : Var} {n : ℕ} {σ : State} →
    -------------------------------------------------
     ⟨ X := const n , σ ⟩ ⟶ₖ ⟨ skip , update σ X n ⟩
  step->> : ∀ {c₁ c₂ c₁′ : Com} {σ σ′ : State} →
            ⟨ c₁ , σ ⟩ ⟶ₖ ⟨ c₁′ , σ′ ⟩ →
    ------------------------------------------
     ⟨ c₁ >> c₂ , σ ⟩ ⟶ₖ ⟨ c₁′ >> c₂ , σ′ ⟩
  skip->> : ∀ {c : Com} {σ : State} →
    ---------------------------------
     ⟨ skip >> c , σ ⟩ ⟶ₖ ⟨ c , σ ⟩
  step-ite : ∀ {b b′ : BExpr} {c₁ c₂ : Com} {σ : State} →
               ⟨ b , σ ⟩ ⟶ₜ b′ →
    ---------------------------------------------
     ⟨ ite b c₁ c₂ , σ ⟩ ⟶ₖ ⟨ ite b′ c₁ c₂ , σ ⟩ 
  ite-true : ∀ {c₁ c₂ : Com} {σ : State} →
    --------------------------------------
     ⟨ ite true c₁ c₂ , σ ⟩ ⟶ₖ ⟨ c₁ , σ ⟩
  ite-false : ∀ {c₁ c₂ : Com} {σ : State} →
    --------------------------------------
     ⟨ ite false c₁ c₂ , σ ⟩ ⟶ₖ ⟨ c₂ , σ ⟩
  step-while : ∀ {b : BExpr} {c : Com} {σ : State} →
    -------------------------------------------------------------------
     ⟨ while b go c , σ ⟩ ⟶ₖ ⟨ ite b (c >> (while b go c)) skip , σ ⟩ 

infixr 2 _⟶ₐ⋆_

data _⟶ₐ⋆_ : AConfig → AExpr → Set where 
  step-zero : ∀ {e : AExpr} {σ : State} →
    -----------------
     ⟨ e , σ ⟩ ⟶ₐ⋆ e
  step-many : ∀ {e₁ e₂ e₃ : AExpr} {σ : State} →
    ⟨ e₁ , σ ⟩ ⟶ₐ  e₂ →
    ⟨ e₂ , σ ⟩ ⟶ₐ⋆ e₃ →
    ---------------------
      ⟨ e₁ , σ ⟩ ⟶ₐ⋆ e₃ 

⟶ₐ⋆-trans : ∀ {e₁ e₂ e₃ : AExpr} {σ : State} →
  ⟨ e₁ , σ ⟩ ⟶ₐ⋆ e₂ →
  ⟨ e₂ , σ ⟩ ⟶ₐ⋆ e₃ →
  --------------------
  ⟨ e₁ , σ ⟩ ⟶ₐ⋆ e₃
⟶ₐ⋆-trans step-zero stps2 = stps2
⟶ₐ⋆-trans (step-many stp stps1) stps2 = step-many stp (⟶ₐ⋆-trans stps1 stps2)

plus-steps₁ : ∀ {e₁ e₁′ e₂ : AExpr} {σ : State} →
        ⟨ e₁ , σ ⟩ ⟶ₐ⋆ e₁′ →
  ------------------------------
   ⟨ e₁ ⊕ e₂ , σ ⟩ ⟶ₐ⋆ e₁′ ⊕ e₂
plus-steps₁ step-zero = step-zero
plus-steps₁ (step-many stp stps) = step-many (plus-step₁ stp) (plus-steps₁ stps)

plus-steps₂ : ∀ {e₁ e₂ e₂′ : AExpr} {σ : State} →
         ⟨ e₂ , σ ⟩ ⟶ₐ⋆ e₂′ →
  -------------------------------
    ⟨ e₁ ⊕ e₂ , σ ⟩ ⟶ₐ⋆ e₁ ⊕ e₂′
plus-steps₂ step-zero = step-zero
plus-steps₂ (step-many stp stps) = step-many (plus-step₂ stp) (plus-steps₂ stps)

minus-steps₁ : ∀ {e₁ e₁′ e₂ : AExpr} {σ : State} →
        ⟨ e₁ , σ ⟩ ⟶ₐ⋆ e₁′ →
  ------------------------------
   ⟨ e₁ - e₂ , σ ⟩ ⟶ₐ⋆ e₁′ - e₂
minus-steps₁ step-zero = step-zero
minus-steps₁ (step-many stp stps) = step-many (minus-step₁ stp) (minus-steps₁ stps)

minus-steps₂ : ∀ {e₁ e₂ e₂′ : AExpr} {σ : State} →
         ⟨ e₂ , σ ⟩ ⟶ₐ⋆ e₂′ →
  -------------------------------
    ⟨ e₁ - e₂ , σ ⟩ ⟶ₐ⋆ e₁ - e₂′
minus-steps₂ step-zero = step-zero
minus-steps₂ (step-many stp stps) = step-many (minus-step₂ stp) (minus-steps₂ stps)

times-steps₁ : ∀ {e₁ e₁′ e₂ : AExpr} {σ : State} →
        ⟨ e₁ , σ ⟩ ⟶ₐ⋆ e₁′ →
  ------------------------------
   ⟨ e₁ ⊗ e₂ , σ ⟩ ⟶ₐ⋆ e₁′ ⊗ e₂
times-steps₁ step-zero = step-zero
times-steps₁ (step-many stp stps) = step-many (times-step₁ stp) (times-steps₁ stps)

times-steps₂ : ∀ {e₁ e₂ e₂′ : AExpr} {σ : State} →
         ⟨ e₂ , σ ⟩ ⟶ₐ⋆ e₂′ →
  -------------------------------
    ⟨ e₁ ⊗ e₂ , σ ⟩ ⟶ₐ⋆ e₁ ⊗ e₂′
times-steps₂ step-zero = step-zero
times-steps₂ (step-many stp stps) = step-many (times-step₂ stp) (times-steps₂ stps)


infixr 2 _⇓ₐ_

data _⇓ₐ_ : AConfig → ℕ → Set where
  const-eval : ∀ {n : ℕ} {σ : State} →
               ----------------------
                ⟨ const n , σ ⟩ ⇓ₐ n
  var-eval : ∀ {x : Var} {σ : State} →
             --------------------------
               ⟨ var x , σ ⟩ ⇓ₐ (σ x)
  plus-eval : ∀ {e1 e2 : AExpr} {σ : State} {n m : ℕ} →
         ⟨ e1 , σ ⟩ ⇓ₐ n →
         ⟨ e2 , σ ⟩ ⇓ₐ m →
    --------------------------
     ⟨ e1 ⊕ e2 , σ ⟩ ⇓ₐ n + m
  minus-eval : ∀ {e1 e2 : AExpr} {σ : State} {n m : ℕ} →
         ⟨ e1 , σ ⟩ ⇓ₐ n →
         ⟨ e2 , σ ⟩ ⇓ₐ m →
    --------------------------
     ⟨ e1 - e2 , σ ⟩ ⇓ₐ n ∸ m
  times-eval : ∀ {e1 e2 : AExpr} {σ : State} {n m : ℕ} →
         ⟨ e1 , σ ⟩ ⇓ₐ n →
         ⟨ e2 , σ ⟩ ⇓ₐ m →
    --------------------------
     ⟨ e1 ⊗ e2 , σ ⟩ ⇓ₐ n * m


⇓ₐ-⟶ₐ⋆ : ∀ {c : AConfig} {n : ℕ} → c ⇓ₐ n → c ⟶ₐ⋆ const n
⇓ₐ-⟶ₐ⋆ {⟨ const n , σ ⟩} {n} const-eval = step-zero
⇓ₐ-⟶ₐ⋆ {⟨ var x , σ ⟩} {n} var-eval = step-many var-lookup step-zero
⇓ₐ-⟶ₐ⋆ {⟨ e1 ⊕ e2 , σ ⟩} {_} (plus-eval {e1} {e2} {σ} {n} {m} ev₁ ev₂) =
  ⟶ₐ⋆-trans (plus-steps₁ (⇓ₐ-⟶ₐ⋆ ev₁))
 (⟶ₐ⋆-trans (plus-steps₂ (⇓ₐ-⟶ₐ⋆ ev₂))
            (step-many plus-step-const step-zero))
⇓ₐ-⟶ₐ⋆ {⟨ e₁ - e₂ , σ ⟩} {_} (minus-eval {e₁} {e₂} {σ} {n} {m} ev₁ ev₂) =
  ⟶ₐ⋆-trans (minus-steps₁ (⇓ₐ-⟶ₐ⋆ ev₁))
 (⟶ₐ⋆-trans (minus-steps₂ (⇓ₐ-⟶ₐ⋆ ev₂))
            (step-many minus-step-const step-zero))
⇓ₐ-⟶ₐ⋆ {c} {n} (times-eval ev₁ ev₂) = 
  ⟶ₐ⋆-trans (times-steps₁ (⇓ₐ-⟶ₐ⋆ ev₁))
 (⟶ₐ⋆-trans (times-steps₂ (⇓ₐ-⟶ₐ⋆ ev₂))
            (step-many times-step-const step-zero))

⟶ₐ-⇓ₐ : ∀ {e₁ e₂ : AExpr} {σ : State} {n : ℕ} →
   ⟨ e₁ , σ ⟩ ⟶ₐ e₂ →
   ⟨ e₂ , σ ⟩ ⇓ₐ n →
  -----------------
   ⟨ e₁ , σ ⟩ ⇓ₐ n
⟶ₐ-⇓ₐ {.(var X)} {.(const (σ X))} {σ} .{σ X} (var-lookup {X} {σ}) const-eval = var-eval
⟶ₐ-⇓ₐ .{e₁ ⊕ e₂} .{e₁′ ⊕ e₂} {σ} .{n + m} (plus-step₁ {e₁} {e₂} {e₁′} {σ} stp) (plus-eval .{e₁′} .{e₂} .{σ} {n} {m} ev₁ ev₂) = plus-eval (⟶ₐ-⇓ₐ stp ev₁) ev₂
⟶ₐ-⇓ₐ {.(e₁ ⊕ e₂)} {.(e₁ ⊕ e₂′)} {σ} .{n + m} (plus-step₂ {e₁} {e₂} {e₂′} {σ} stp) (plus-eval .{e₁} .{e₂′} .{σ} {n} {m} ev₁ ev₂) = plus-eval ev₁ (⟶ₐ-⇓ₐ stp ev₂)
⟶ₐ-⇓ₐ {.(const n ⊕ const m)} {.(const (n + m))} {σ} {.(n + m)} (plus-step-const {n} {m} {σ}) const-eval = plus-eval const-eval const-eval
⟶ₐ-⇓ₐ .{e₁ - e₂} .{e₁′ - e₂} {σ} .{n ∸ m} (minus-step₁ {e₁} {e₂} {e₁′} {σ} stp) (minus-eval .{e₁′} .{e₂} .{σ} {n} {m} ev₁ ev₂) = minus-eval (⟶ₐ-⇓ₐ stp ev₁) ev₂
⟶ₐ-⇓ₐ {.(e₁ - e₂)} {.(e₁ - e₂′)} {σ} .{n ∸ m} (minus-step₂ {e₁} {e₂} {e₂′} {σ} stp) (minus-eval .{e₁} .{e₂′} .{σ} {n} {m} ev₁ ev₂) = minus-eval ev₁ (⟶ₐ-⇓ₐ stp ev₂)
⟶ₐ-⇓ₐ {.(const n - const m)} {.(const (n ∸ m))} {σ} {.(n ∸ m)} (minus-step-const {n} {m} {σ}) const-eval = minus-eval const-eval const-eval
⟶ₐ-⇓ₐ .{e₁ ⊗ e₂} .{e₁′ ⊗ e₂} {σ} .{n * m} (times-step₁ {e₁} {e₂} {e₁′} {σ} stp) (times-eval .{e₁′} .{e₂} .{σ} {n} {m} ev₁ ev₂) = times-eval (⟶ₐ-⇓ₐ stp ev₁) ev₂
⟶ₐ-⇓ₐ {.(e₁ ⊗ e₂)} {.(e₁ ⊗ e₂′)} {σ} .{n * m} (times-step₂ {e₁} {e₂} {e₂′} {σ} stp) (times-eval .{e₁} .{e₂′} .{σ} {n} {m} ev₁ ev₂) = times-eval ev₁ (⟶ₐ-⇓ₐ stp ev₂)
⟶ₐ-⇓ₐ {.(const n ⊗ const m)} {.(const (n * m))} {σ} {.(n * m)} (times-step-const {n} {m} {σ}) const-eval = times-eval const-eval const-eval

⟶ₐ⋆-⇓ₐ : ∀ {c : AConfig} {n : ℕ} →
   c ⟶ₐ⋆ const n →
  ---------------
      c ⇓ₐ n
⟶ₐ⋆-⇓ₐ step-zero = const-eval
⟶ₐ⋆-⇓ₐ (step-many stp stps) = ⟶ₐ-⇓ₐ stp (⟶ₐ⋆-⇓ₐ stps)


infixr 2 _⟶ₜ⋆_
data _⟶ₜ⋆_ : BConfig → BExpr → Set where
  step-zero : ∀ {b : BExpr}{σ : State} → ⟨ b , σ ⟩ ⟶ₜ⋆ b
  step-many : ∀ {b₁ b₂ b₃ : BExpr} {σ : State} →
    ⟨ b₁ , σ ⟩ ⟶ₜ  b₂ →
    ⟨ b₂ , σ ⟩ ⟶ₜ⋆ b₃ →
    ⟨ b₁ , σ ⟩ ⟶ₜ⋆ b₃

{- THESE SHOULD BE A HW Q -}
⟶ₜ⋆-trans : ∀ {b₁ b₂ b₃ : BExpr} {σ : State} →
  ⟨ b₁ , σ ⟩ ⟶ₜ⋆ b₂ →
  ⟨ b₂ , σ ⟩ ⟶ₜ⋆ b₃ →
  ⟨ b₁ , σ ⟩ ⟶ₜ⋆ b₃
⟶ₜ⋆-trans step-zero stps2 = stps2
⟶ₜ⋆-trans (step-many stp stps1) stps2 = step-many stp (⟶ₜ⋆-trans stps1 stps2)

eq-steps₁ : ∀ {e₁ e₁′ e₂ : AExpr} {σ : State} →
  ⟨ e₁ , σ ⟩ ⟶ₐ⋆ e₁′ →
  ⟨ e₁ == e₂ , σ ⟩ ⟶ₜ⋆ e₁′ == e₂
eq-steps₁ step-zero = step-zero
eq-steps₁ (step-many stp stps) = step-many (eq-step₁ stp) (eq-steps₁ stps)

eq-steps₂ : ∀ {e₁ e₂ e₂′ : AExpr} {σ : State} →
  ⟨ e₂ , σ ⟩ ⟶ₐ⋆ e₂′ →
  ⟨ e₁ == e₂ , σ ⟩ ⟶ₜ⋆ e₁ == e₂′ 
eq-steps₂ step-zero = step-zero
eq-steps₂ (step-many stp stps) = step-many (eq-step₂ stp) (eq-steps₂ stps)

lt-steps₁ : ∀ {e₁ e₁′ e₂ : AExpr} {σ : State} →
  ⟨ e₁ , σ ⟩ ⟶ₐ⋆ e₁′ →
  ⟨ e₁ << e₂ , σ ⟩ ⟶ₜ⋆ e₁′ << e₂
lt-steps₁ step-zero = step-zero
lt-steps₁ (step-many stp stps) = step-many (lt-step₁ stp) (lt-steps₁ stps)

lt-steps₂ : ∀ {e₁ e₂ e₂′ : AExpr} {σ : State} →
  ⟨ e₂ , σ ⟩ ⟶ₐ⋆ e₂′ →
  ⟨ e₁ << e₂ , σ ⟩ ⟶ₜ⋆ e₁ << e₂′ 
lt-steps₂ step-zero = step-zero
lt-steps₂ (step-many stp stps) = step-many (lt-step₂ stp) (lt-steps₂ stps)

not-steps : ∀ {b₁ b₂ : BExpr} {σ : State} →
  ⟨ b₁ , σ ⟩ ⟶ₜ⋆ b₂ →
  ⟨ ! b₁ , σ ⟩ ⟶ₜ⋆ ! b₂
not-steps step-zero = step-zero
not-steps (step-many stp stps) = step-many (not-step stp) (not-steps stps)

and-steps₁ : ∀ {b₁ b₁′ b₂ : BExpr} {σ : State} →
  ⟨ b₁ , σ ⟩ ⟶ₜ⋆ b₁′ →
  ⟨ b₁ && b₂ , σ ⟩ ⟶ₜ⋆ b₁′ && b₂
and-steps₁ step-zero = step-zero
and-steps₁ (step-many stp stps) = step-many (and-step₁ stp) (and-steps₁ stps)

or-steps₁ : ∀ {b₁ b₁′ b₂ : BExpr} {σ : State} →
  ⟨ b₁ , σ ⟩ ⟶ₜ⋆ b₁′ →
  ⟨ b₁ || b₂ , σ ⟩ ⟶ₜ⋆ b₁′ || b₂
or-steps₁ step-zero = step-zero
or-steps₁ (step-many stp stps) = step-many (or-step₁ stp) (or-steps₁ stps)

{- END HW -}

notb : Bool → Bool
notb true = false
notb false = true

andb : Bool → Bool → Bool
andb false b2 = false
andb true b2 = b2

orb : Bool → Bool → Bool
orb false b2 = b2
orb true b2 = true

infixr 2 _⇓ₜ_
data _⇓ₜ_ : BConfig → Bool → Set where
     false-eval : ∀ {σ : State} → ⟨ false , σ ⟩ ⇓ₜ false
     true-eval : ∀ {σ : State} → ⟨ true , σ ⟩ ⇓ₜ true
     eq-eval-true : ∀ {e₁ e₂ : AExpr} {σ : State} {n : ℕ} →
              ⟨ e₁ , σ ⟩ ⇓ₐ n →
              ⟨ e₂ , σ ⟩ ⇓ₐ n →
       ---------------------------
        ⟨ e₁ == e₂ , σ ⟩ ⇓ₜ true
     eq-eval-false : ∀ {e₁ e₂ : AExpr} {σ : State} {n m : ℕ} →
             ⟨ e₁ , σ ⟩ ⇓ₐ n →
             ⟨ e₂ , σ ⟩ ⇓ₐ m →
                  n ≢ m →
       --------------------------
       ⟨ e₁ == e₂ , σ ⟩ ⇓ₜ false
     lt-eval-true : ∀ {e₁ e₂ : AExpr} {σ : State} {n m : ℕ} →
              ⟨ e₁ , σ ⟩ ⇓ₐ n →
              ⟨ e₂ , σ ⟩ ⇓ₐ m →
                       n < m →
       ----------------------------
        ⟨ e₁ << e₂ , σ ⟩ ⇓ₜ true
     lt-eval-false : ∀ {e₁ e₂ : AExpr} {σ : State} {n m : ℕ} →
              ⟨ e₁ , σ ⟩ ⇓ₐ n →
              ⟨ e₂ , σ ⟩ ⇓ₐ m →
                       ¬ (n < m) →
       ----------------------------
        ⟨ e₁ << e₂ , σ ⟩ ⇓ₜ false
     not-eval : ∀ {b : BExpr} {σ : State} {b′ : Bool} → 
          ⟨ b , σ ⟩ ⇓ₜ b′ →
       ------------------------
        ⟨ ! b , σ ⟩ ⇓ₜ notb b′
     and-eval-true : ∀ {b₁ b₂ : BExpr} {σ : State} {b₂′ : Bool} →
              ⟨ b₁ , σ ⟩ ⇓ₜ true →
              ⟨ b₂ , σ ⟩ ⇓ₜ b₂′ →
       ----------------------------------
        ⟨ b₁ && b₂ , σ ⟩ ⇓ₜ b₂′
     and-eval-false : ∀ {b₁ b₂ : BExpr} {σ : State} → 
              ⟨ b₁ , σ ⟩ ⇓ₜ false →
       ----------------------------------
        ⟨ b₁ && b₂ , σ ⟩ ⇓ₜ false
     or-eval-true : ∀ {b₁ b₂ : BExpr} {σ : State} →
              ⟨ b₁ , σ ⟩ ⇓ₜ true →
       ----------------------------------
        ⟨ b₁ || b₂ , σ ⟩ ⇓ₜ true
     or-eval-false : ∀ {b₁ b₂ : BExpr} {σ : State} {b₂′ : Bool} → 
              ⟨ b₁ , σ ⟩ ⇓ₜ false →
              ⟨ b₂ , σ ⟩ ⇓ₜ b₂′ → 
       ----------------------------------
        ⟨ b₁ || b₂ , σ ⟩ ⇓ₜ b₂′ 

and-eval : ∀ {b₁ b₂ : BExpr} {σ : State} {b₁′ b₂′ : Bool} →
  ⟨ b₁ , σ ⟩ ⇓ₜ b₁′ →
  ⟨ b₂ , σ ⟩ ⇓ₜ b₂′ →
  ⟨ b₁ && b₂ , σ ⟩ ⇓ₜ andb b₁′ b₂′
and-eval {b₁} {b₂} {σ} {false} {b₂′} ev₁ ev₂ = and-eval-false ev₁
and-eval {b₁} {b₂} {σ} {true} {b₂′} ev₁ ev₂ = and-eval-true ev₁ ev₂

or-eval : ∀ {b₁ b₂ : BExpr} {σ : State} {b₁′ b₂′ : Bool} →
  ⟨ b₁ , σ ⟩ ⇓ₜ b₁′ →
  ⟨ b₂ , σ ⟩ ⇓ₜ b₂′ →
  ⟨ b₁ || b₂ , σ ⟩ ⇓ₜ orb b₁′ b₂′
or-eval {b₁} {b₂} {σ} {false} {b₂′} ev₁ ev₂ = or-eval-false ev₁ ev₂
or-eval {b₁} {b₂} {σ} {true} {b₂′} ev₁ ev₂ = or-eval-true ev₁


{- This should be a homework question -}

⇓ₜ-⟶ₜ⋆ : ∀ {c : BConfig} {b : Bool} → c ⇓ₜ b → c ⟶ₜ⋆ bool2BExpr b
⇓ₜ-⟶ₜ⋆ false-eval = step-zero
⇓ₜ-⟶ₜ⋆ true-eval = step-zero
⇓ₜ-⟶ₜ⋆ (eq-eval-true ev₁ ev₂) =
   ⟶ₜ⋆-trans (eq-steps₁ (⇓ₐ-⟶ₐ⋆ ev₁))
  (⟶ₜ⋆-trans (eq-steps₂ (⇓ₐ-⟶ₐ⋆ ev₂))
             (step-many eq-step-true step-zero))
⇓ₜ-⟶ₜ⋆ (eq-eval-false ev₁ ev₂ neq) =
   ⟶ₜ⋆-trans (eq-steps₁ (⇓ₐ-⟶ₐ⋆ ev₁))
  (⟶ₜ⋆-trans (eq-steps₂ (⇓ₐ-⟶ₐ⋆ ev₂))
             (step-many (eq-step-false neq) step-zero))
⇓ₜ-⟶ₜ⋆ (lt-eval-true ev₁ ev₂ n<m) =
   ⟶ₜ⋆-trans (lt-steps₁ (⇓ₐ-⟶ₐ⋆ ev₁))
  (⟶ₜ⋆-trans (lt-steps₂ (⇓ₐ-⟶ₐ⋆ ev₂))
             (step-many (lt-step-true n<m) step-zero))
⇓ₜ-⟶ₜ⋆ (lt-eval-false ev₁ ev₂ m≤n) =
   ⟶ₜ⋆-trans (lt-steps₁ (⇓ₐ-⟶ₐ⋆ ev₁))
  (⟶ₜ⋆-trans (lt-steps₂ (⇓ₐ-⟶ₐ⋆ ev₂))
             (step-many (lt-step-false m≤n) step-zero))
⇓ₜ-⟶ₜ⋆ {c} {.(notb false)} (not-eval {_} {_} {false} ev) = ⟶ₜ⋆-trans (not-steps (⇓ₜ-⟶ₜ⋆ ev)) (step-many not-false step-zero)
⇓ₜ-⟶ₜ⋆ {c} {.(notb true)} (not-eval {_} {_} {true} ev) = ⟶ₜ⋆-trans (not-steps (⇓ₜ-⟶ₜ⋆ ev)) (step-many not-true step-zero)
⇓ₜ-⟶ₜ⋆ (and-eval-true ev₁ ev₂) = ⟶ₜ⋆-trans (and-steps₁ (⇓ₜ-⟶ₜ⋆ ev₁)) (step-many and-true (⇓ₜ-⟶ₜ⋆ ev₂))
⇓ₜ-⟶ₜ⋆ (and-eval-false ev₁) = ⟶ₜ⋆-trans (and-steps₁ (⇓ₜ-⟶ₜ⋆ ev₁)) (step-many and-false step-zero)
⇓ₜ-⟶ₜ⋆ (or-eval-true ev) = ⟶ₜ⋆-trans (or-steps₁ (⇓ₜ-⟶ₜ⋆ ev)) (step-many or-true step-zero) 
⇓ₜ-⟶ₜ⋆ (or-eval-false ev₁ ev₂) = ⟶ₜ⋆-trans (or-steps₁ (⇓ₜ-⟶ₜ⋆ ev₁)) (step-many or-false (⇓ₜ-⟶ₜ⋆ ev₂))

⟶ₜ-⇓ₜ : ∀ {b₁ b₂ : BExpr} {σ : State} {b : Bool} → ⟨ b₁ , σ ⟩ ⟶ₜ b₂ → ⟨ b₂ , σ ⟩ ⇓ₜ b → ⟨ b₁ , σ ⟩ ⇓ₜ b
⟶ₜ-⇓ₜ (eq-step₁ stp) (eq-eval-true ev₁ ev₂) = eq-eval-true (⟶ₐ-⇓ₐ stp ev₁) ev₂
⟶ₜ-⇓ₜ (eq-step₁ stp) (eq-eval-false ev₁ ev₂ neq) = eq-eval-false (⟶ₐ-⇓ₐ stp ev₁) ev₂ neq
⟶ₜ-⇓ₜ (eq-step₂ stp) (eq-eval-true ev₁ ev₂) = eq-eval-true ev₁ (⟶ₐ-⇓ₐ stp ev₂)
⟶ₜ-⇓ₜ (eq-step₂ stp) (eq-eval-false ev₁ ev₂ neq) = eq-eval-false ev₁ (⟶ₐ-⇓ₐ stp ev₂) neq
⟶ₜ-⇓ₜ eq-step-true true-eval = eq-eval-true const-eval const-eval
⟶ₜ-⇓ₜ (eq-step-false neq) false-eval = eq-eval-false const-eval const-eval neq
⟶ₜ-⇓ₜ (lt-step₁ stp) (lt-eval-true ev₁ ev₂ n<m) = lt-eval-true (⟶ₐ-⇓ₐ stp ev₁) ev₂ n<m
⟶ₜ-⇓ₜ (lt-step₁ stp) (lt-eval-false ev₁ ev₂ m≤n) = lt-eval-false (⟶ₐ-⇓ₐ stp ev₁) ev₂ m≤n
⟶ₜ-⇓ₜ (lt-step₂ stp) (lt-eval-true ev₁ ev₂ n<m) = lt-eval-true ev₁ (⟶ₐ-⇓ₐ stp ev₂) n<m
⟶ₜ-⇓ₜ (lt-step₂ stp) (lt-eval-false ev₁ ev₂ m≤n) = lt-eval-false ev₁ (⟶ₐ-⇓ₐ stp ev₂) m≤n
⟶ₜ-⇓ₜ (lt-step-true n<m) true-eval = lt-eval-true const-eval const-eval n<m
⟶ₜ-⇓ₜ (lt-step-false m≥n) false-eval = lt-eval-false const-eval const-eval m≥n
⟶ₜ-⇓ₜ (not-step stp) (not-eval ev) = not-eval (⟶ₜ-⇓ₜ stp ev)
⟶ₜ-⇓ₜ {b₁} {b₂} {σ} {false} not-true false-eval = not-eval true-eval
⟶ₜ-⇓ₜ {b₁} {b₂} {σ} {true} not-false true-eval = not-eval false-eval
⟶ₜ-⇓ₜ (and-step₁ stp) (and-eval-true ev₁ ev₂) = and-eval-true (⟶ₜ-⇓ₜ stp ev₁) ev₂
⟶ₜ-⇓ₜ (and-step₁ stp) (and-eval-false ev) = and-eval-false (⟶ₜ-⇓ₜ stp ev)
⟶ₜ-⇓ₜ {true && b₂} {b₂} {σ} {b} and-true ev = and-eval-true true-eval ev
⟶ₜ-⇓ₜ and-false false-eval = and-eval-false false-eval
⟶ₜ-⇓ₜ (or-step₁ stp) (or-eval-true ev) = or-eval-true (⟶ₜ-⇓ₜ stp ev)
⟶ₜ-⇓ₜ (or-step₁ stp) (or-eval-false ev₁ ev₂) = or-eval-false (⟶ₜ-⇓ₜ stp ev₁) ev₂
⟶ₜ-⇓ₜ or-true true-eval = or-eval-true true-eval
⟶ₜ-⇓ₜ or-false ev = or-eval-false false-eval ev

⟶ₜ⋆-⇓ₜ : ∀ {b : BExpr} {σ : State} {b′ : Bool} → ⟨ b , σ ⟩ ⟶ₜ⋆ bool2BExpr b′ → ⟨ b , σ ⟩ ⇓ₜ b′
⟶ₜ⋆-⇓ₜ {.(bool2BExpr false)} {σ} {false} step-zero = false-eval
⟶ₜ⋆-⇓ₜ {.(bool2BExpr true)} {σ} {true} step-zero = true-eval
⟶ₜ⋆-⇓ₜ (step-many stp stps) = ⟶ₜ-⇓ₜ stp (⟶ₜ⋆-⇓ₜ stps)

-- postulate
  -- ⇓ₜ-⟶ₜ⋆ : ∀ {c : BConfig} {b : Bool} → c ⇓ₜ b → c ⟶ₜ⋆ bool2BExpr b
  -- ⟶ₜ-⇓ₜ : ∀ {b₁ b₂ : BExpr} {σ : State} {b : Bool} → ⟨ b₁ , σ ⟩ ⟶ₜ b₂ → ⟨ b₂ , σ ⟩ ⇓ₜ b → ⟨ b₁ , σ ⟩ ⇓ₜ b
  -- ⟶ₜ⋆-⇓ₜ : ∀ {b : BExpr} {σ : State} {b′ : Bool} → ⟨ b , σ ⟩ ⟶ₜ⋆ bool2BExpr b′ → ⟨ b , σ ⟩ ⇓ₜ b′


infixr 2 _⟶ₖ⋆_

data _⟶ₖ⋆_ : Config → Config → Set where
  step-none : ∀ {c : Config} → c ⟶ₖ⋆ c
  step-many : ∀ {c₁ c₂ c₃ : Config} → c₁ ⟶ₖ c₂ → c₂ ⟶ₖ⋆ c₃ → c₁ ⟶ₖ⋆ c₃

⟶ₖ⋆-trans : ∀ {c₁ c₂ c₃ : Config} →
  c₁ ⟶ₖ⋆ c₂ →
  c₂ ⟶ₖ⋆ c₃ →
  ----------
  c₁ ⟶ₖ⋆ c₃
⟶ₖ⋆-trans step-none stps = stps
⟶ₖ⋆-trans (step-many stp stps₁) stps₂ = step-many stp (⟶ₖ⋆-trans stps₁ stps₂)

assgn-steps : ∀ {X : Var} {e₁ e₂ : AExpr} {σ : State} →
  ⟨ e₁ , σ ⟩ ⟶ₐ⋆ e₂ →
  ⟨ X := e₁ , σ ⟩ ⟶ₖ⋆ ⟨ X := e₂ , σ ⟩
assgn-steps step-zero = step-none
assgn-steps (step-many stp stps) = step-many (step-assgn stp) (assgn-steps stps)

seq-steps₁ : ∀ {c₁ c₁′ c₂ : Com} {σ₁ σ₂ : State} →
  ⟨ c₁ , σ₁ ⟩ ⟶ₖ⋆ ⟨ c₁′ , σ₂ ⟩ →
  ⟨ c₁ >> c₂ , σ₁ ⟩ ⟶ₖ⋆ ⟨ c₁′ >> c₂ , σ₂ ⟩
seq-steps₁ step-none = step-none
seq-steps₁ (step-many stp stps) = step-many (step->> stp) (seq-steps₁ stps)

ite-steps : ∀ {b b′ : BExpr} {c₁ c₂ : Com} {σ : State} →
  ⟨ b , σ ⟩ ⟶ₜ⋆ b′ →
  ⟨ ite b c₁ c₂ , σ ⟩ ⟶ₖ⋆ ⟨ ite b′ c₁ c₂ , σ ⟩
ite-steps step-zero = step-none
ite-steps (step-many stp stps) = step-many (step-ite stp) (ite-steps stps) 

infixr 2 _⇓_
  
data _⇓_ : Config → State → Set where
  skip-eval : ∀ {σ : State} →
    ------------------
     ⟨ skip , σ ⟩ ⇓ σ
  assgn-eval : ∀ {X : Var} {e : AExpr} {σ : State} {n : ℕ} →
          ⟨ e , σ ⟩ ⇓ₐ n →
    --------------------------------
     ⟨ X := e , σ ⟩ ⇓ update σ X n 
  seq-eval : ∀ {c₁ c₂ : Com} {σ₁ σ₂ σ₃ : State} →
           ⟨ c₁ , σ₁ ⟩ ⇓ σ₂ →
           ⟨ c₂ , σ₂ ⟩ ⇓ σ₃ →
    ------------------------
     ⟨ c₁ >> c₂ , σ₁ ⟩ ⇓ σ₃
  ite-eval-true : ∀ {b : BExpr} {c₁ c₂ : Com} {σ₁ σ₂ : State} →
        ⟨ b  , σ₁ ⟩ ⇓ₜ true →
        ⟨ c₁ , σ₁ ⟩ ⇓  σ₂ →
    ---------------------------
     ⟨ ite b c₁ c₂ , σ₁ ⟩ ⇓ σ₂
  ite-eval-false : ∀ {b : BExpr} {c₁ c₂ : Com} {σ₁ σ₂ : State} →
        ⟨ b  , σ₁ ⟩ ⇓ₜ false →
        ⟨ c₂ , σ₁ ⟩ ⇓  σ₂ →
    ---------------------------
     ⟨ ite b c₁ c₂ , σ₁ ⟩ ⇓ σ₂
  while-eval-true : ∀ {b : BExpr} {c : Com} {σ₁ σ₂ σ₃ : State} →
    ⟨ b , σ₁ ⟩ ⇓ₜ true →
    ⟨ c , σ₁ ⟩ ⇓ σ₂ →
    ⟨ while b go c , σ₂ ⟩ ⇓ σ₃ →
    ----------------------------------
    ⟨ while b go c , σ₁ ⟩ ⇓ σ₃
  while-eval-false : ∀ {b : BExpr} {c : Com} {σ : State} →
    ⟨ b , σ ⟩ ⇓ₜ false →
    -------------------------
    ⟨ while b go c , σ ⟩ ⇓ σ

⇓-⟶ₖ⋆ : ∀ {c : Com} {σ₁ σ₂ : State} → ⟨ c , σ₁ ⟩ ⇓ σ₂ → ⟨ c , σ₁ ⟩ ⟶ₖ⋆ ⟨ skip , σ₂ ⟩
⇓-⟶ₖ⋆ skip-eval = step-none
⇓-⟶ₖ⋆ (assgn-eval ev) = ⟶ₖ⋆-trans (assgn-steps (⇓ₐ-⟶ₐ⋆ ev)) (step-many assgn-const step-none)
⇓-⟶ₖ⋆ (seq-eval ev₁ ev₂) = ⟶ₖ⋆-trans (seq-steps₁ (⇓-⟶ₖ⋆ ev₁)) (step-many skip->> (⇓-⟶ₖ⋆ ev₂))
⇓-⟶ₖ⋆ (ite-eval-true ev₁ ev₂) = ⟶ₖ⋆-trans (ite-steps (⇓ₜ-⟶ₜ⋆ ev₁)) (step-many ite-true (⇓-⟶ₖ⋆ ev₂))
⇓-⟶ₖ⋆ (ite-eval-false ev₁ ev₂) = ⟶ₖ⋆-trans (ite-steps (⇓ₜ-⟶ₜ⋆ ev₁)) (step-many ite-false (⇓-⟶ₖ⋆ ev₂))
⇓-⟶ₖ⋆ (while-eval-true ev₁ ev₂ ev₃) = ⟶ₖ⋆-trans (step-many step-while (⟶ₖ⋆-trans (ite-steps (⇓ₜ-⟶ₜ⋆ ev₁)) (step-many ite-true step-none))) (⟶ₖ⋆-trans (seq-steps₁ (⇓-⟶ₖ⋆ ev₂)) (step-many skip->> (⇓-⟶ₖ⋆ ev₃)))
⇓-⟶ₖ⋆ (while-eval-false ev) = step-many step-while (⟶ₖ⋆-trans (ite-steps (⇓ₜ-⟶ₜ⋆ ev)) (step-many ite-false step-none))

⟶ₖ-⇓ : ∀ {c₁ c₂ : Config} {σ : State} → c₁ ⟶ₖ c₂ → c₂ ⇓ σ → c₁ ⇓ σ
⟶ₖ-⇓ (step-assgn stp) (assgn-eval ev) = assgn-eval (⟶ₐ-⇓ₐ stp ev)
⟶ₖ-⇓ assgn-const skip-eval = assgn-eval const-eval
⟶ₖ-⇓ (step->> stp) (seq-eval ev₁ ev₂) = seq-eval (⟶ₖ-⇓ stp ev₁) ev₂
⟶ₖ-⇓ skip->> ev = seq-eval skip-eval ev
⟶ₖ-⇓ (step-ite stp) (ite-eval-true ev₁ ev₂) = ite-eval-true (⟶ₜ-⇓ₜ stp ev₁) ev₂
⟶ₖ-⇓ (step-ite stp) (ite-eval-false ev₁ ev₂) = ite-eval-false (⟶ₜ-⇓ₜ stp ev₁) ev₂
⟶ₖ-⇓ ite-true ev = ite-eval-true true-eval ev
⟶ₖ-⇓ ite-false ev = ite-eval-false false-eval ev
⟶ₖ-⇓ step-while (ite-eval-true ev₁ (seq-eval ev₂ ev₃)) = while-eval-true ev₁ ev₂ ev₃
⟶ₖ-⇓ step-while (ite-eval-false ev₁ skip-eval) = while-eval-false ev₁

⟶ₖ⋆-⇓ : ∀ {c : Com} {σ₁ σ₂ : State} → ⟨ c , σ₁ ⟩ ⟶ₖ⋆ ⟨ skip , σ₂ ⟩ → ⟨ c , σ₁ ⟩ ⇓ σ₂
⟶ₖ⋆-⇓ step-none = skip-eval
⟶ₖ⋆-⇓ (step-many stp stps) = ⟶ₖ-⇓ stp (⟶ₖ⋆-⇓ stps)

evalA : AConfig → ℕ
evalA ⟨ const n , σ ⟩ = n
evalA ⟨ var x , σ ⟩ = σ x
evalA ⟨ e₁ ⊕ e₂ , σ ⟩ = let x = evalA ⟨ e₁ , σ ⟩ in let y = evalA ⟨ e₂ , σ ⟩ in x + y 
evalA ⟨ e₁ - e₂ , σ ⟩ = let x = evalA ⟨ e₁ , σ ⟩ in let y = evalA ⟨ e₂ , σ ⟩ in x ∸ y 
evalA ⟨ e₁ ⊗ e₂ , σ ⟩ = let x = evalA ⟨ e₁ , σ ⟩ in let y = evalA ⟨ e₂ , σ ⟩ in x * y

evalA-⇓ₐ : ∀ (c : AConfig) → c ⇓ₐ (evalA c)
evalA-⇓ₐ ⟨ const n , σ ⟩ = const-eval
evalA-⇓ₐ ⟨ var x , σ ⟩ = var-eval
evalA-⇓ₐ ⟨ e₁ ⊕ e₂ , σ ⟩ = plus-eval (evalA-⇓ₐ ⟨ e₁ , σ ⟩) (evalA-⇓ₐ ⟨ e₂ , σ ⟩)
evalA-⇓ₐ ⟨ e₁ - e₂ , σ ⟩ = minus-eval (evalA-⇓ₐ ⟨ e₁ , σ ⟩) (evalA-⇓ₐ ⟨ e₂ , σ ⟩)
evalA-⇓ₐ ⟨ e₁ ⊗ e₂ , σ ⟩ = times-eval (evalA-⇓ₐ ⟨ e₁ , σ ⟩) (evalA-⇓ₐ ⟨ e₂ , σ ⟩)

⇓ₐ-evalA : ∀ {c : AConfig} {n : ℕ} → c ⇓ₐ n → evalA c ≡ n
⇓ₐ-evalA {⟨ const n , σ ⟩} {n} const-eval = refl
⇓ₐ-evalA {⟨ var X , σ ⟩} {n} var-eval = refl
⇓ₐ-evalA {⟨ e₁ ⊕ e₂ , σ ⟩} {n} (plus-eval ev₁ ev₂) rewrite ⇓ₐ-evalA ev₁ | ⇓ₐ-evalA ev₂ = refl
⇓ₐ-evalA {⟨ e₁ - e₂ , σ ⟩} {n} (minus-eval ev₁ ev₂) rewrite ⇓ₐ-evalA ev₁ | ⇓ₐ-evalA ev₂ = refl
⇓ₐ-evalA {⟨ e₁ ⊗ e₂ , σ ⟩} {n} (times-eval ev₁ ev₂) rewrite ⇓ₐ-evalA ev₁ | ⇓ₐ-evalA ev₂ = refl

evalB : BConfig → Bool
evalB ⟨ true , σ ⟩ = true
evalB ⟨ false , σ ⟩ = false
evalB ⟨ e₁ == e₂ , σ ⟩ = nat-eqb (evalA ⟨ e₁ , σ ⟩) (evalA ⟨ e₂ , σ ⟩)
evalB ⟨ e₁ << e₂ , σ ⟩ = ltb (evalA ⟨ e₁ , σ ⟩) (evalA ⟨ e₂ , σ ⟩)
evalB ⟨ ! b , σ ⟩ = notb (evalB ⟨ b , σ ⟩)
evalB ⟨ b₁ && b₂ , σ ⟩ = andb (evalB ⟨ b₁ , σ ⟩) (evalB ⟨ b₂ , σ ⟩)
evalB ⟨ b₁ || b₂ , σ ⟩ = orb (evalB ⟨ b₁ , σ ⟩) (evalB ⟨ b₂ , σ ⟩)


evalB-⇓ₜ : ∀ (c : BConfig) → c ⇓ₜ (evalB c)
evalB-⇓ₜ ⟨ true , σ ⟩ = true-eval
evalB-⇓ₜ ⟨ false , σ ⟩ = false-eval
evalB-⇓ₜ ⟨ e₁ == e₂ , σ ⟩ with (evalA ⟨ e₁ , σ ⟩) ≟ (evalA ⟨ e₂ , σ ⟩)
... | yes eq rewrite nat-eqb-equal eq = eq-eval-true (evalA-⇓ₐ ⟨ e₁ , σ ⟩ ) ev
    where
      ev : ⟨ e₂ , σ ⟩ ⇓ₐ evalA ⟨ e₁ , σ ⟩
      ev rewrite eq = evalA-⇓ₐ ⟨ e₂ , σ ⟩
... | no neq rewrite nat-eqb-nequal neq = eq-eval-false (evalA-⇓ₐ ⟨ e₁ , σ ⟩) (evalA-⇓ₐ ⟨ e₂ , σ ⟩) neq
evalB-⇓ₜ ⟨ e₁ << e₂ , σ ⟩ with (evalA ⟨ e₁ , σ ⟩) <? (evalA ⟨ e₂ , σ ⟩ )
... | yes pf rewrite <-ltb pf = lt-eval-true (evalA-⇓ₐ ⟨ e₁ , σ ⟩) (evalA-⇓ₐ ⟨ e₂ , σ ⟩) pf
... | no pf rewrite ≮-ltb pf = lt-eval-false (evalA-⇓ₐ ⟨ e₁ , σ ⟩) (evalA-⇓ₐ ⟨ e₂ , σ ⟩) pf 
evalB-⇓ₜ ⟨ ! b , σ ⟩ = not-eval (evalB-⇓ₜ ⟨ b , σ ⟩) 
evalB-⇓ₜ ⟨ b₁ && b₂ , σ ⟩ = and-eval (evalB-⇓ₜ ⟨ b₁ , σ ⟩) (evalB-⇓ₜ ⟨ b₂ , σ ⟩) 
evalB-⇓ₜ ⟨ b₁ || b₂ , σ ⟩ = or-eval (evalB-⇓ₜ ⟨ b₁ , σ ⟩) (evalB-⇓ₜ ⟨ b₂ , σ ⟩)

evalB-≡-⇓ₜ : ∀ {c : BConfig} {b : Bool} → evalB c ≡ b → c ⇓ₜ b
evalB-≡-⇓ₜ {c} {b} eq rewrite (sym eq) = evalB-⇓ₜ c 

⇓ₜ-evalB : ∀ {c : BConfig} {b : Bool} → c ⇓ₜ b → evalB c ≡ b
⇓ₜ-evalB {⟨ false , σ ⟩} {b} false-eval = refl
⇓ₜ-evalB {⟨ true , σ ⟩} {b} true-eval = refl
⇓ₜ-evalB {⟨ e₁ == e₂ , σ ⟩} {true} (eq-eval-true {e₁} {e₂} {σ} {n} ev₁ ev₂) rewrite ⇓ₐ-evalA ev₁ | ⇓ₐ-evalA ev₂ = nat-eqb-refl {n}
⇓ₜ-evalB {⟨ e₁ == e₂ , σ ⟩} {false} (eq-eval-false {e₁} {e₂} {σ} {n} {m} ev₁ ev₂ neq) rewrite ⇓ₐ-evalA ev₁ | ⇓ₐ-evalA ev₂ = nat-eqb-nequal neq
⇓ₜ-evalB {⟨ e₁ << e₂ , σ ⟩} {true} (lt-eval-true {e₁} {e₂} {σ} {n} {m} ev₁ ev₂ n<m) rewrite ⇓ₐ-evalA ev₁ | ⇓ₐ-evalA ev₂ = <-ltb n<m
⇓ₜ-evalB {⟨ e₁ << e₂ , σ ⟩} {b} (lt-eval-false {e₁} {e₂} {σ} {n} {m} ev₁ ev₂ n≮m) rewrite ⇓ₐ-evalA ev₁ | ⇓ₐ-evalA ev₂ = ≮-ltb n≮m
⇓ₜ-evalB {⟨ ! b , σ ⟩ } {_} (not-eval ev) = cong notb (⇓ₜ-evalB ev)
⇓ₜ-evalB {⟨ b₁ && b₂ , σ ⟩} {b} (and-eval-true ev₁ ev₂) rewrite ⇓ₜ-evalB ev₁ = ⇓ₜ-evalB ev₂
⇓ₜ-evalB {⟨ b₁ && b₂ , σ ⟩} {false} (and-eval-false ev) rewrite ⇓ₜ-evalB ev = refl
⇓ₜ-evalB {⟨ b₁ || b₂ , σ ⟩} {b} (or-eval-true ev) rewrite ⇓ₜ-evalB ev = refl
⇓ₜ-evalB {⟨ b₁ || b₂ , σ ⟩} {b} (or-eval-false ev₁ ev₂) rewrite ⇓ₜ-evalB ev₁ = ⇓ₜ-evalB ev₂
\end{code}

\section{Introduction to Axiomatic Semantics}
\label{sec:intr-axiom-semant}

\begin{itemize}
\item Consider the following \Imp program~$c$:
  $$
  \begin{array}{l}
    X := n;~Y := m;~Z := 0\\
    \textsf{while}\mkern8mu0 < Y\mkern8mu\textsf{do}\\
    ~~Z := Z + X;~Y := Y - 1
  \end{array}
  $$
\item It's easy to see that in any state, after running this program $Z$ will contain $n * m$ (no matter what $n$ and $m$ are).
  But how do we prove it?
\item One option: try to prove it from the operational semantics.
  This is doable, but requires a large amount of work.
\item Another option: prove that the denotational semantics of~$c$ are equal to the function $\lambda \sigma.\, \sigma[Z \mapsto nm]$.
  This takes a lot of work, and manual reasoning about the fixpoint.
\item The idea of axiomatic semantics is to give imperative programs (i.e., programs in \Imp-like languages) a semantics which is better suited to this sort of verification problem.
\item The idea of axiomatic semantics is to give every instruction in a program a \emph{precondition} and a \emph{postcondition}.
  \begin{itemize}
  \item That way, if the precondition is true before running that instruction, then the postcondition is true after running that instruction.
  \end{itemize}
\item Our goal, then is to justify the following:
  $$
  \begin{array}{l}
    \{ \itrue \}\\
    X := \tilde{n};~Y := \tilde{m};~Z := \tilde{0}\\
    \textsf{while}\mkern8mu\tilde{0} < Y\mkern8mu\textsf{do}\\
    ~~Z := Z + X;~Y := Y - \tilde{1}\\
    \{ Z = nm \}
  \end{array}
  $$
  \begin{itemize}
  \item Here, the assertions in brackets are the pre- and postcondition.
  \item So, we know that if \itrue is true before the program is run (and it always is), then $Z=nm$ will hold afterwords.
  \end{itemize}
\item It is easy to build up pre- and postconditions for most statements.
\item For instance, we might have the following:
  $$
  \begin{array}{l}
    \{ \itrue \}\\
    X := \tilde{n};\\
    \{X = n\}\\
    Y := \tilde{m};\\
    \{X = n \land Y = m\}\\
    Z := \tilde{0}\\
    \{X = n \land Y = m \land Z = 0\}\\
    \textsf{while}\mkern8mu\tilde{0} < Y\mkern8mu\textsf{do}\\
    ~~Z := Z + X;~Y := Y - \tilde{1}\\
    \{ Z = nm \}
  \end{array}
  $$
\item In other words, we know that each assignment statement will set their variable appropriately.
\item The difficult part in reasoning about \Imp programs like this is reasoning about \emph{loops}.
\item Here, we need to come up with an \emph{invariant} for the loop: something that is true for every iteration of the loop.
  \begin{itemize}
  \item This requires some human creativity! 
  \item Automatic invariant detection is an unsolvable problem (but an active area of research).
  \end{itemize}
\item In this case, we can use the invariant $$Z = n(m-Y) \land 0 \leq Y \leq m$$
\item This is true every time we begin and end the loop, though it might not be true in the middle.
  \begin{itemize}
  \item In other words, the loop body can break the invariant, as long as it fixes it again.
  \end{itemize}
\item At the end of the loop, we know that $Y = 0$, so $Z = n(m-0) = nm$ as desired.
\item Our goal today is to formalize this type of reasoning.
\end{itemize}

\section{The Axiomatic Semantics of \Imp}
\label{sec:axiom-semant-imp}

\begin{itemize}
\item We write $\hoare{P}{c}{Q}$ to mean ``if $P$ is before we run $c$ and $c$ terminates, then $Q$ will be true of the resulting state.''
\item This is called a \emph{Hoare triple}
  \begin{itemize}
  \item They are named after Sir Tony Hoare, who invented them in the 60s.
  \item The style of axiomatic semantics we're looking at today is sometimes called Hoare logic in his honor.
  \end{itemize}
\item Note that we don't require that $c$ terminates!
  There are versions of axiomatic semantics that require this, but we won't see them in this course.
\item What are $P$ and $Q$ here?
  Just predicates on state!
  In other words, $P, Q \colon \textsf{State} \to \textsf{Set}$.
\item We will use a couple of constructions on predicates about state:
  \begin{itemize}
  \item Any boolean expression~$b$ gives rise to two predicates on the state: one stating that $b$ is true and one stating that $b$ is false.
    We write these $\uparrow b$ and $\uparrow\lnot b$ respectively.
\begin{code}
↑ : BExpr → State → Set
↑ b σ = evalB ⟨ b , σ ⟩ ≡ true

↑¬ : BExpr → State → Set
↑¬ b σ = evalB ⟨ b , σ ⟩ ≡ false    
\end{code}
  \item Moreover, given any two predicates on state~$P$ and~$Q$, we can ask if they are both true about some state (which we write $P \land Q$) or if $P$ being true implies that $Q$ is true (which we write $P \implies Q$).
\begin{code}
_∧_ : (State → Set) → (State → Set) → State → Set
(P ∧ Q) σ = P σ × Q σ

_⇒_ : (State → Set) → (State → Set) → Set
P ⇒ Q = ∀ (σ : State) → P σ → Q σ    
\end{code}
\item Finally, if $f \colon \textsf{State} \to \textsf{State}$, then $P[X \mapsto f]$ is the predicate that holds of $\sigma$ exactly when $P$ holds of $\sigma[X \mapsto f(\sigma)]$
  \end{itemize}
\item We can then give a proof system for Hoare triples as follows (we write $\vdash \hoare{P}{c}{Q}$ to mean that the Hoare triple $\hoare{P}{c}{Q}$ is provable):
  \begin{mathpar}
    \infer*[left=reasoning]{R \implies P\\ Q \implies S\\ \vdash \hoare{P}{c}{Q}}{\vdash \hoare{R}{c}{S}}\\
    \infer*[left=skip]{ }{\vdash \hoare{P}{\Skip}{P}} \and
    \infer*[right=assign]{}{\vdash \hoare{P[X \mapsto \llbracket e \rrbracket]}{X := e}{P}}\\
    \infer*[left=seq]{\vdash \hoare{P}{c_1}{Q}\\\vdash \hoare{Q}{c_2}{R}}{\vdash \hoare{P}{c_1;c_2}{R}} \and
    \infer*[right=ite]{\vdash \hoare{P \land \uparrow b}{c_1}{Q}\\\vdash \hoare{P \land \uparrow\lnot b}{c_2}{Q}}{\vdash \hoare{P}{\ite{b}{c_1}{c_2}}{Q}}\\
    \infer*[left=while]{\vdash \hoare{P \land \uparrow b}{c}{P}}{\vdash \hoare{P}{\while{b}{c}}{P \land \uparrow\lnot b}}
  \end{mathpar}

\item Let's look at each of these in turn:
  \begin{itemize}
  \item The \textsc{reasoning}~rule says that you can replace the predicates in a Hoare triple by a predicate that implies the precondition and a predicate the postcondition implies.
    Intuitively, we can transform evidence that $R$ holds into evidence that $P$ holds, so proving $R$ still allows us to establish that $Q$ holds after running $c$.
    Because $Q$ implies $S$, the fact that we established $Q$ holds means that we know that $S$ must also hold.

    \textbf{N.B.:} The implication on the left-hand side is ``backwards''.
    This is called contravariance, and we will meet it again later when we look at subtyping.
  \item The \textsc{skip}~rule says that if $P$ holds before doing nothing, the $P$ still holds afterwords.
  \item The \textsc{assign}~rule says that if we know $P$ holds in a state where $X$ contains the value of $e$, then $P$ holds after assigning $X$ to $e$.
  \item The \textsc{seq}~rule says that we can reason about two composed commands in sequence by coming up with a predicate that holds after the first command and before the second command.
  \item The \textsc{ite}~rule says that we can reason about an \textsf{if} command by reasoning about both branches.
    In each branch, we get to know what the outcome of the test was.
  \item Finally, the \textsc{while}~rule says that if $P$ is an invariant of the body of the loop~$c$, and $P$ holds before the loop starts, then it will still hold after the loop ends.
    However, we get to know that the outcome of the test was positive when running $c$, and after the loop ends we know that the outcome of the test was negative.
  \end{itemize}
  \pagebreak
\item This can be done in agda:
\begin{code}
data [[_]]_[[_]] : (State → Set) → Com → (State → Set) → Set₁ where
  reasoning-hoare : ∀ {P Q R S : State → Set} {c : Com} →
         (R ⇒ P) →
         (Q ⇒ S) →
    [[ P ]] c [[ Q ]] →
    ------------------
    [[ R ]] c [[ S ]]
  skip-hoare : ∀ {P : State → Set} →
    --------------------
    [[ P ]] skip [[ P ]]
  assgn-hoare : ∀ {P : State → Set} {X : Var} {e : AExpr} →
    ---------------------------------------------------------------
    [[ (λ σ → P (update σ X (evalA ⟨ e , σ ⟩))) ]] X := e [[ P ]]
  seq-hoare : ∀ {P Q R : State → Set} {c₁ c₂ : Com} →
        [[ P ]] c₁ [[ Q ]] →
        [[ Q ]] c₂ [[ R ]] →
    ------------------------------
    [[ P ]] (c₁ >> c₂) [[ R ]]
  ite-hoare : ∀ {P Q : State → Set} {c₁ c₂ : Com} {b : BExpr} →
    [[ P ∧ (↑ b) ]] c₁ [[ Q ]] →
    [[ P ∧ ↑¬ b ]] c₂ [[ Q ]] →
    ------------------------------
    [[ P ]] (ite b c₁ c₂) [[ Q ]]
  while-hoare : ∀ {P : State → Set} {c : Com} {b : BExpr} →
         [[ P ∧ ↑ b ]] c [[ P ]] →
    ----------------------------------
    [[ P ]] while b go c [[ P ∧ ↑¬ b ]]    
\end{code}
\item Let's take a look at the first statement from our example above, where
  $$P = \mathop{\uparrow}(X = n)[X \mapsto \llbracket \tilde{n}\rrbracket]$$
  \begin{mathpar}
    \infer*[Left=reasoning]{ \itrue \implies P\\
      \uparrow(X = n) \implies \uparrow(X = n)\\
      \infer*[left=assign]{ }{\hoare{P}{X := \tilde{n}}{\uparrow(X = n)}}}
    {\hoare{\itrue}{X := \tilde{n}}{\uparrow(X = n)}}
  \end{mathpar}
  The first line of reasoning there comes from the fact that for any state~$\sigma$, $X = n$ holds in $\sigma[X \mapsto n]$.
  Thus, the Hoare triple we gave earlier for the first line is correct.
\item Let's also look at the while loop from the example above:
  $$
  \begin{array}{l}
    \{X = n \land Y = m \land Z = 0\} \implies \{X = n \land 0 \leq Y \land Y \leq m \land Z = n * (m - Y)\}\\
    \textsf{while}\mkern8mu\tilde{0} < Y\mkern8mu\textsf{do}\\
    ~~\{0 < Y \land X = n \land 0 \leq Y \land Y \leq m \land Z = n * (m - Y)\} \implies\\
    ~~\{X = n \land 0 < Y \land Y \leq m \land Z + X = n * (m - (Y - 1))\}\\
    ~~Z := Z + X;\\
    ~~\{X = n \land 0 < Y \land Y \leq m \land Z = n * (m - (Y - 1))\} \implies\\
    ~~\{X = n \land 0 \leq Y - \tilde{1} \land Y - \tilde{1} \leq m \land Z = n * (m - (Y - 1))\}\\
    ~~Y := Y - \tilde{1}\\
    ~~\{X = n \land 0 \leq Y \land Y \leq m \land Z = n * (m - Y)\}\\
    \{\lnot 0 < Y \land X = n \land 0 \leq Y \land Y \leq m \land Z = n * (m - Y)\} \implies\\
    \{ Z = nm \}
  \end{array}
  $$
\item This style of ``decorated program'' is very common.
\item The steps labeled with an implication are an application of the \textsc{reasoning} rule, while the other steps are applications of the rules determined by the structure of the program.
\item If you are interested in doing stuff with this style of verification, check out the Dafny programming language.
\end{itemize}

\section{Soundness of the Axiomatic Semantics}
\label{sec:soundn-axiom-semant}

\begin{itemize}
\item We now have yet another semantics for commands.
  We need to prove that it's sound!
\item We need to choose which previous semantics to prove it sound with regards to.
  Since they're all equivalent, it doesn't really matter.
  Here we choose the big-step operational semantics, since that makes it slightly easier.
\end{itemize}

\begin{thm}[Axiomatic Semantics Soundness]
  For any state predicates~$P$ and~$Q$, command~$c$, and states~$\sigma_1$ and~$\sigma_2$, if $\vdash \hoare{P}{c}{Q}$ $\langle c, \sigma_1 \rangle \Downarrow \sigma_2$, and $P(\sigma_1)$ holds, then $Q(\sigma_2)$ holds.
\end{thm}
\begin{proof}
  By induction on the proof of $\vdash \hoare{P}{c}{Q}$.

  \noindent\textbf{Case \textsc{reasoning}:}
  In this case, we know that $P \implies R$, $S \implies Q$, and $\vdash \hoare{R}{c}{S}$.
  (Note the reversal in names from the rule.)
  By IH, we know that if $R(\sigma_1)$ then $S(\sigma_2)$.
  But we also know (since it is given) that $P(\sigma_1)$ holds, and since $P \implies R$, we know that $R(\sigma_1)$ holds.
  That means that $S(\sigma_2)$ holds, and therefore that $Q(\sigma_2)$ holds, as desired.

  \noindent\textbf{Case \textsc{skip}:}
  In this case, we know that $\sigma_2 = \sigma_1$ and $Q = P$, so we are given the desired evidence that $P(\sigma_1)$ holds.

  \noindent\textbf{Case \textsc{assign}:}
  In this case, we know that $P = Q[X \mapsto \llbracket e \rrbracket]$.
  Furthermore, since $\langle X := e , \sigma_1 \rangle \Downarrow \sigma_2$, we know that $\sigma_2 = \sigma_1[X \mapsto \llbracket e \rrbracket(\sigma_1)]$.
  But then $P(\sigma_1)$ is exactly the same as $Q(\sigma_2)$, which is what we needed to show.

  \noindent\textbf{Case \textsc{ite}:}
  We further split on whether the proof of $\langle \ite{b}{c_1}{c_2}, \sigma_1\rangle\Downarrow \sigma_2$ comes from \textsc{ite-true} or \textsc{ite-false}.
  In the first case, we know that $\llbracket b \rrbracket(\sigma_1)$ is true, and so we know that $(P \land \uparrow b)(\sigma_1)$ holds.
  By IH, then, $Q(\sigma_2)$ holds, as desired.
  The second case is similar, but we know that $\llbracket b \rrbracket(\sigma_1)$ is \emph{false}, and so we know that $(P \land \uparrow\lnot b)(\sigma_1)$ holds.

  \noindent\textbf{Case \textsc{while}:}
  Again, we split on whether the proof of $\langle \while{b}{c}, \sigma_1 \rangle \Downarrow \sigma_2$ comes from \textsc{while-true} or \textsc{while-false}.
  In the first case, we know that $\llbracket b \rrbracket(\sigma_1)$ is true, and thus that $(P \land \uparrow b)(\sigma_1)$ is true.
  Furthermore, we know that there is some state~$\sigma$ such that $\langle c, \sigma_1 \rangle \Downarrow \sigma$ and $\langle \while{b}{c}, \sigma\rangle \Downarrow \sigma_2$.
  Thus, by IH, we know that $P(\sigma)$ holds, and thus that $(P \land \uparrow\lnot b)(\sigma_2)$ holds, as desired.
  In the second case, we know that $\llbracket b \rrbracket(\sigma_1)$ is false, and thus that $(P\land\uparrow\lnot b)(\sigma_1)$ holds, as desired.
\end{proof}

\newpage
\begin{code}
hoare-sound : ∀ {P Q : State → Set} {c : Com} →
  [[ P ]] c [[ Q ]] →
  ∀ (σ₁ σ₂ : State) →
  (⟨ c , σ₁ ⟩ ⇓  σ₂) →
  ---------------------
      P σ₁ → Q σ₂
hoare-sound {P} {Q} {c} (reasoning-hoare {R} {S} {P} {Q} H1 H2 hr) σ₁ σ₂ ev Pσ₁ =
  H2 σ₂ (hoare-sound hr σ₁ σ₂ ev (H1 σ₁ Pσ₁))
hoare-sound {P} .{P} .{skip} skip-hoare σ₁ .(σ₁) skip-eval Pσ₁ = Pσ₁
hoare-sound {P} {Q} {X := e} assgn-hoare σ₁ σ₂ (assgn-eval {X} {e} {σ} {n} ev) Pσ₁
  rewrite ⇓ₐ-evalA ev = Pσ₁
hoare-sound {P} {Q} {c₁ >> c₂} (seq-hoare hr₁ hr₂) σ₁ σ₃
                               (seq-eval {c₁} {c₂} {σ₁} {σ₂} {σ₃} ev₁ ev₂) Pσ₁ =
    hoare-sound hr₂ σ₂ σ₃ ev₂ (hoare-sound hr₁ σ₁ σ₂ ev₁ Pσ₁)
hoare-sound {P} {Q} {ite b c₁ c₂} (ite-hoare hr₁ hr₂) σ₁ σ₂ (ite-eval-true ev₁ ev₂) Pσ₁ =
    hoare-sound hr₁ σ₁ σ₂ ev₂ ⟨ Pσ₁ ,  ⇓ₜ-evalB ev₁ ⟩
hoare-sound {P} {Q} {c} (ite-hoare hr₁ hr₂) σ₁ σ₂ (ite-eval-false ev₁ ev₂) Pσ₁ =
    hoare-sound hr₂ σ₁ σ₂ ev₂ ⟨ Pσ₁ , ⇓ₜ-evalB ev₁ ⟩ 
hoare-sound {P} .{P ∧ ↑¬ b} {while b go c} (while-hoare hr) σ₁ σ₃
                                           (while-eval-true {b} {c} {σ₁} {σ₂} {σ₃} ev₁ ev₂ ev₃) Pσ₁ =
    hoare-sound (while-hoare hr) σ₂ σ₃ ev₃ (hoare-sound hr σ₁ σ₂ ev₂ ⟨ Pσ₁ , ⇓ₜ-evalB ev₁ ⟩)
hoare-sound {P} .{P ∧ ↑¬ b} {while b go c} (while-hoare hr) σ₁ .(σ₁)
                                           (while-eval-false {b} {c} {σ₁} ev) Pσ₁ =
    ⟨ Pσ₁ , ⇓ₜ-evalB ev ⟩  
\end{code}

\subsection{Whither completeness?}
\label{sec:whither-completeness}

\begin{itemize}
\item You might ask why we don't prove completeness of the Hoare-logic~rules above.
\item In order to establish completeness, we need to build up the theory of \emph{weakest preconditions} and \emph{predicate transformers}.
\item This requires a deeper dive into some areas of mathematics and logic (such as order theory and domain theory) than we're going to go into in this class.
\item For now, we have the proof of soundness, and you will have to trust me that it is complete.
\end{itemize}

\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% TeX-engine: luatex
%%% TeX-command-default: "Make"
%%% End:
